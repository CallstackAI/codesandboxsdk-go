/*
CodeSandbox API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2023-07-01
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package csdkgo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// VmAPIService VmAPI service
type VmAPIService service

type ApiVmHibernateRequest struct {
	ctx context.Context
	ApiService *VmAPIService
	id string
	body *interface{}
}

// VM Hibernate Request
func (r ApiVmHibernateRequest) Body(body interface{}) ApiVmHibernateRequest {
	r.body = &body
	return r
}

func (r ApiVmHibernateRequest) Execute() (*VMHibernateResponse, *http.Response, error) {
	return r.ApiService.VmHibernateExecute(r)
}

/*
VmHibernate Hibernate a VM

Suspends a running VM, saving a snapshot of its memory and running processes

This endpoint may take an extended amount of time to return (30 seconds). If the VM is not
currently running, it will return an error (404).

Unless later shut down by request or due to inactivity, a hibernated VM can be resumed with
minimal latency.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Sandbox ID
 @return ApiVmHibernateRequest
*/
func (a *VmAPIService) VmHibernate(ctx context.Context, id string) ApiVmHibernateRequest {
	return ApiVmHibernateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VMHibernateResponse
func (a *VmAPIService) VmHibernateExecute(r ApiVmHibernateRequest) (*VMHibernateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VMHibernateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VmAPIService.VmHibernate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vm/{id}/hibernate"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVmShutdownRequest struct {
	ctx context.Context
	ApiService *VmAPIService
	id string
	body *interface{}
}

// VM Shutdown Request
func (r ApiVmShutdownRequest) Body(body interface{}) ApiVmShutdownRequest {
	r.body = &body
	return r
}

func (r ApiVmShutdownRequest) Execute() (*VMShutdownResponse, *http.Response, error) {
	return r.ApiService.VmShutdownExecute(r)
}

/*
VmShutdown Shutdown a VM

Stops a running VM, ending all currently running processes

This endpoint may take an extended amount of time to return (30 seconds). If the VM is not
currently running, it will return an error (404).

Shutdown VMs require additional time to start up.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Sandbox ID
 @return ApiVmShutdownRequest
*/
func (a *VmAPIService) VmShutdown(ctx context.Context, id string) ApiVmShutdownRequest {
	return ApiVmShutdownRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VMShutdownResponse
func (a *VmAPIService) VmShutdownExecute(r ApiVmShutdownRequest) (*VMShutdownResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VMShutdownResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VmAPIService.VmShutdown")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vm/{id}/shutdown"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVmStartRequest struct {
	ctx context.Context
	ApiService *VmAPIService
	id string
	vMStartRequest *VMStartRequest
}

// VM Start Request
func (r ApiVmStartRequest) VMStartRequest(vMStartRequest VMStartRequest) ApiVmStartRequest {
	r.vMStartRequest = &vMStartRequest
	return r
}

func (r ApiVmStartRequest) Execute() (*VMStartResponse, *http.Response, error) {
	return r.ApiService.VmStartExecute(r)
}

/*
VmStart Start a VM

Start a virtual machine for the sandbox (devbox) with the given ID

While the `sandbox:read` scope is required for this endpoint, the resulting VM will have
permissions according to the `sandbox:edit_code` scope. If present, the returned token will
have write permissions to the contents of the VM. Otherwise, the returned token will grant
only read-only permissions.

This endpoint is subject to special rate limits related to concurrent VM usage.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Sandbox ID
 @return ApiVmStartRequest
*/
func (a *VmAPIService) VmStart(ctx context.Context, id string) ApiVmStartRequest {
	return ApiVmStartRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VMStartResponse
func (a *VmAPIService) VmStartExecute(r ApiVmStartRequest) (*VMStartResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VMStartResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VmAPIService.VmStart")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vm/{id}/start"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vMStartRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVmUpdateHibernationTimeoutRequest struct {
	ctx context.Context
	ApiService *VmAPIService
	id string
	vMUpdateHibernationTimeoutRequest *VMUpdateHibernationTimeoutRequest
}

// VM Update Hibernation Timeout Request
func (r ApiVmUpdateHibernationTimeoutRequest) VMUpdateHibernationTimeoutRequest(vMUpdateHibernationTimeoutRequest VMUpdateHibernationTimeoutRequest) ApiVmUpdateHibernationTimeoutRequest {
	r.vMUpdateHibernationTimeoutRequest = &vMUpdateHibernationTimeoutRequest
	return r
}

func (r ApiVmUpdateHibernationTimeoutRequest) Execute() (*VMUpdateHibernationTimeoutResponse, *http.Response, error) {
	return r.ApiService.VmUpdateHibernationTimeoutExecute(r)
}

/*
VmUpdateHibernationTimeout Update VM Hibernation Timeout

Updates the hibernation timeout of a running VM.

This endpoint can only be used on VMs that belong to your team's workspace.
The new timeout must be greater than 0 and less than or equal to 86400 seconds (24 hours).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Sandbox ID
 @return ApiVmUpdateHibernationTimeoutRequest
*/
func (a *VmAPIService) VmUpdateHibernationTimeout(ctx context.Context, id string) ApiVmUpdateHibernationTimeoutRequest {
	return ApiVmUpdateHibernationTimeoutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VMUpdateHibernationTimeoutResponse
func (a *VmAPIService) VmUpdateHibernationTimeoutExecute(r ApiVmUpdateHibernationTimeoutRequest) (*VMUpdateHibernationTimeoutResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VMUpdateHibernationTimeoutResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VmAPIService.VmUpdateHibernationTimeout")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vm/{id}/hibernation_timeout"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vMUpdateHibernationTimeoutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVmUpdateSpecsRequest struct {
	ctx context.Context
	ApiService *VmAPIService
	id string
	vMUpdateSpecsRequest *VMUpdateSpecsRequest
}

// VM Update Specs Request
func (r ApiVmUpdateSpecsRequest) VMUpdateSpecsRequest(vMUpdateSpecsRequest VMUpdateSpecsRequest) ApiVmUpdateSpecsRequest {
	r.vMUpdateSpecsRequest = &vMUpdateSpecsRequest
	return r
}

func (r ApiVmUpdateSpecsRequest) Execute() (*VMUpdateSpecsResponse, *http.Response, error) {
	return r.ApiService.VmUpdateSpecsExecute(r)
}

/*
VmUpdateSpecs Update VM Specs

Updates the specifications (CPU, memory, storage) of a running VM.

This endpoint can only be used on VMs that belong to your team's workspace.
The new tier must not exceed your team's maximum allowed tier.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Sandbox ID
 @return ApiVmUpdateSpecsRequest
*/
func (a *VmAPIService) VmUpdateSpecs(ctx context.Context, id string) ApiVmUpdateSpecsRequest {
	return ApiVmUpdateSpecsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VMUpdateSpecsResponse
func (a *VmAPIService) VmUpdateSpecsExecute(r ApiVmUpdateSpecsRequest) (*VMUpdateSpecsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VMUpdateSpecsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VmAPIService.VmUpdateSpecs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vm/{id}/specs"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vMUpdateSpecsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVmUpdateSpecs2Request struct {
	ctx context.Context
	ApiService *VmAPIService
	id string
	vMUpdateSpecsRequest *VMUpdateSpecsRequest
}

// VM Update Specs Request
func (r ApiVmUpdateSpecs2Request) VMUpdateSpecsRequest(vMUpdateSpecsRequest VMUpdateSpecsRequest) ApiVmUpdateSpecs2Request {
	r.vMUpdateSpecsRequest = &vMUpdateSpecsRequest
	return r
}

func (r ApiVmUpdateSpecs2Request) Execute() (*VMUpdateSpecsResponse, *http.Response, error) {
	return r.ApiService.VmUpdateSpecs2Execute(r)
}

/*
VmUpdateSpecs2 Update VM Specs

Updates the specifications (CPU, memory, storage) of a running VM.

This endpoint can only be used on VMs that belong to your team's workspace.
The new tier must not exceed your team's maximum allowed tier.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Sandbox ID
 @return ApiVmUpdateSpecs2Request
*/
func (a *VmAPIService) VmUpdateSpecs2(ctx context.Context, id string) ApiVmUpdateSpecs2Request {
	return ApiVmUpdateSpecs2Request{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VMUpdateSpecsResponse
func (a *VmAPIService) VmUpdateSpecs2Execute(r ApiVmUpdateSpecs2Request) (*VMUpdateSpecsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VMUpdateSpecsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VmAPIService.VmUpdateSpecs2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vm/{id}/update_specs"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vMUpdateSpecsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
