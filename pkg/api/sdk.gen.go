// Package csbapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.2.0 DO NOT EDIT.
package csbapi

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	AuthorizationScopes = "authorization.Scopes"
)

// Defines values for SandboxCreateRequestRuntime.
const (
	Browser SandboxCreateRequestRuntime = "browser"
	Vm      SandboxCreateRequestRuntime = "vm"
)

// Defines values for VMCreateSessionRequestPermission.
const (
	Read  VMCreateSessionRequestPermission = "read"
	Write VMCreateSessionRequestPermission = "write"
)

// MetaInformation defines model for MetaInformation.
type MetaInformation struct {
	// Api Meta information about the CodeSandbox API
	Api struct {
		LatestVersion string `json:"latest_version"`
		Name          string `json:"name"`
	} `json:"api"`

	// Auth Meta information about the current authentication context
	Auth *struct {
		Scopes  []string            `json:"scopes"`
		Team    *openapi_types.UUID `json:"team"`
		Version string              `json:"version"`
	} `json:"auth,omitempty"`

	// RateLimits Current workspace rate limits
	RateLimits *struct {
		ConcurrentVms struct {
			Limit     *int `json:"limit,omitempty"`
			Remaining *int `json:"remaining,omitempty"`
		} `json:"concurrent_vms"`
		RequestsHourly struct {
			Limit     *int `json:"limit,omitempty"`
			Remaining *int `json:"remaining,omitempty"`
			Reset     *int `json:"reset,omitempty"`
		} `json:"requests_hourly"`
		SandboxesHourly struct {
			Limit     *int `json:"limit,omitempty"`
			Remaining *int `json:"remaining,omitempty"`
			Reset     *int `json:"reset,omitempty"`
		} `json:"sandboxes_hourly"`
	} `json:"rate_limits,omitempty"`
}

// PreviewHostListResponse defines model for PreviewHostListResponse.
type PreviewHostListResponse struct {
	Data *struct {
		PreviewHosts []struct {
			Host       string `json:"host"`
			InsertedAt string `json:"inserted_at"`
		} `json:"preview_hosts"`
	} `json:"data,omitempty"`
	Errors  *[]PreviewHostListResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                                  `json:"success,omitempty"`
}

// PreviewHostListResponseErrors0 defines model for .
type PreviewHostListResponseErrors0 = string

// PreviewHostListResponseErrors1 defines model for .
type PreviewHostListResponseErrors1 map[string]interface{}

// PreviewHostListResponse_Errors_Item defines model for PreviewHostListResponse.errors.Item.
type PreviewHostListResponse_Errors_Item struct {
	union json.RawMessage
}

// PreviewHostRequest defines model for PreviewHostRequest.
type PreviewHostRequest struct {
	Hosts []string `json:"hosts"`
}

// PreviewToken defines model for PreviewToken.
type PreviewToken struct {
	ExpiresAt   *string `json:"expires_at"`
	LastUsedAt  *string `json:"last_used_at"`
	TokenId     string  `json:"token_id"`
	TokenPrefix string  `json:"token_prefix"`
}

// PreviewTokenCreateRequest defines model for PreviewTokenCreateRequest.
type PreviewTokenCreateRequest struct {
	// ExpiresAt UTC Timestamp until when this token is valid. Omitting this field will create a token without an expiry.
	ExpiresAt *time.Time `json:"expires_at"`
}

// PreviewTokenCreateResponse defines model for PreviewTokenCreateResponse.
type PreviewTokenCreateResponse struct {
	Data *struct {
		SandboxId string `json:"sandbox_id"`
		Token     struct {
			ExpiresAt   *string `json:"expires_at"`
			LastUsedAt  *string `json:"last_used_at"`
			Token       string  `json:"token"`
			TokenId     string  `json:"token_id"`
			TokenPrefix string  `json:"token_prefix"`
		} `json:"token"`
	} `json:"data,omitempty"`
	Errors  *[]PreviewTokenCreateResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                                     `json:"success,omitempty"`
}

// PreviewTokenCreateResponseErrors0 defines model for .
type PreviewTokenCreateResponseErrors0 = string

// PreviewTokenCreateResponseErrors1 defines model for .
type PreviewTokenCreateResponseErrors1 map[string]interface{}

// PreviewTokenCreateResponse_Errors_Item defines model for PreviewTokenCreateResponse.errors.Item.
type PreviewTokenCreateResponse_Errors_Item struct {
	union json.RawMessage
}

// PreviewTokenListResponse defines model for PreviewTokenListResponse.
type PreviewTokenListResponse struct {
	Data *struct {
		SandboxId string         `json:"sandbox_id"`
		Tokens    []PreviewToken `json:"tokens"`
	} `json:"data,omitempty"`
	Errors  *[]PreviewTokenListResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                                   `json:"success,omitempty"`
}

// PreviewTokenListResponseErrors0 defines model for .
type PreviewTokenListResponseErrors0 = string

// PreviewTokenListResponseErrors1 defines model for .
type PreviewTokenListResponseErrors1 map[string]interface{}

// PreviewTokenListResponse_Errors_Item defines model for PreviewTokenListResponse.errors.Item.
type PreviewTokenListResponse_Errors_Item struct {
	union json.RawMessage
}

// PreviewTokenRevokeAllResponse defines model for PreviewTokenRevokeAllResponse.
type PreviewTokenRevokeAllResponse struct {
	Data    *map[string]interface{}                      `json:"data,omitempty"`
	Errors  *[]PreviewTokenRevokeAllResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                                        `json:"success,omitempty"`
}

// PreviewTokenRevokeAllResponseErrors0 defines model for .
type PreviewTokenRevokeAllResponseErrors0 = string

// PreviewTokenRevokeAllResponseErrors1 defines model for .
type PreviewTokenRevokeAllResponseErrors1 map[string]interface{}

// PreviewTokenRevokeAllResponse_Errors_Item defines model for PreviewTokenRevokeAllResponse.errors.Item.
type PreviewTokenRevokeAllResponse_Errors_Item struct {
	union json.RawMessage
}

// PreviewTokenUpdateRequest defines model for PreviewTokenUpdateRequest.
type PreviewTokenUpdateRequest struct {
	// ExpiresAt UTC Timestamp until when this token is valid. Omitting this field will create a token without an expiry.
	ExpiresAt *time.Time `json:"expires_at"`
}

// PreviewTokenUpdateResponse defines model for PreviewTokenUpdateResponse.
type PreviewTokenUpdateResponse struct {
	Data *struct {
		SandboxId string       `json:"sandbox_id"`
		Token     PreviewToken `json:"token"`
	} `json:"data,omitempty"`
	Errors  *[]PreviewTokenUpdateResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                                     `json:"success,omitempty"`
}

// PreviewTokenUpdateResponseErrors0 defines model for .
type PreviewTokenUpdateResponseErrors0 = string

// PreviewTokenUpdateResponseErrors1 defines model for .
type PreviewTokenUpdateResponseErrors1 map[string]interface{}

// PreviewTokenUpdateResponse_Errors_Item defines model for PreviewTokenUpdateResponse.errors.Item.
type PreviewTokenUpdateResponse_Errors_Item struct {
	union json.RawMessage
}

// Sandbox defines model for Sandbox.
type Sandbox struct {
	CreatedAt   time.Time `json:"created_at"`
	Description *string   `json:"description"`
	Id          string    `json:"id"`
	IsFrozen    bool      `json:"is_frozen"`
	Privacy     int       `json:"privacy"`
	Tags        []string  `json:"tags"`
	Title       *string   `json:"title"`
	UpdatedAt   time.Time `json:"updated_at"`
}

// SandboxCreateRequest defines model for SandboxCreateRequest.
type SandboxCreateRequest struct {
	// Description Optional text description of the sandbox. Defaults to no description.
	Description *string `json:"description,omitempty"`

	// Entry Filename of the entrypoint of the sandbox.
	Entry *string `json:"entry,omitempty"`

	// ExternalResources Array of strings with external resources to load.
	ExternalResources *[]string `json:"external_resources,omitempty"`

	// Files Map of `path => file` where each file is a map.
	Files map[string]struct {
		// BinaryContent If the file has binary (non plain-text) contents, place the base-64 encoded contents in this key. Should be empty or missing if `is_binary` is `false`.
		BinaryContent *string `json:"binary_content,omitempty"`

		// Code If the file is non-binary in nature, place the (escaped) plain text contents in this key. Should be empty or missing if `is_binary` is `true`.
		Code *string `json:"code,omitempty"`

		// IsBinary Whether the file contains binary contents.
		IsBinary *bool `json:"is_binary,omitempty"`
	} `json:"files"`

	// IsFrozen Whether changes to the sandbox are disallowed. Defaults to `false`.
	IsFrozen *bool `json:"is_frozen,omitempty"`

	// NpmDependencies Map of dependencies and their version specifications.
	NpmDependencies *map[string]string `json:"npm_dependencies,omitempty"`

	// Path Path to the collection where the new sandbox should be stored. Defaults to "/". If no collection exists at the given path, it will be created.
	Path *string `json:"path,omitempty"`

	// Privacy 0 for public, 1 for unlisted, and 2 for private. Privacy is subject to certain restrictions (team minimum setting, drafts must be private, etc.). Defaults to public.
	Privacy *int `json:"privacy,omitempty"`

	// Runtime Runtime to use for the sandbox. Defaults to `"browser"`.
	Runtime *SandboxCreateRequestRuntime `json:"runtime,omitempty"`

	// Tags List of string tags to apply to the sandbox. Only the first ten will be used. Defaults to no tags.
	Tags *[]string `json:"tags,omitempty"`

	// Template Name of the template from which the sandbox is derived (for example, `"static"`).
	Template *string `json:"template,omitempty"`

	// Title Sandbox title. Maximum 255 characters. Defaults to no title.
	Title *string `json:"title,omitempty"`
}

// SandboxCreateRequestRuntime Runtime to use for the sandbox. Defaults to `"browser"`.
type SandboxCreateRequestRuntime string

// SandboxCreateResponse defines model for SandboxCreateResponse.
type SandboxCreateResponse struct {
	Data *struct {
		Alias string  `json:"alias"`
		Id    string  `json:"id"`
		Title *string `json:"title"`
	} `json:"data,omitempty"`
	Errors  *[]SandboxCreateResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                                `json:"success,omitempty"`
}

// SandboxCreateResponseErrors0 defines model for .
type SandboxCreateResponseErrors0 = string

// SandboxCreateResponseErrors1 defines model for .
type SandboxCreateResponseErrors1 map[string]interface{}

// SandboxCreateResponse_Errors_Item defines model for SandboxCreateResponse.errors.Item.
type SandboxCreateResponse_Errors_Item struct {
	union json.RawMessage
}

// SandboxForkRequest defines model for SandboxForkRequest.
type SandboxForkRequest struct {
	// Description Sandbox description. Maximum 255 characters. Defaults to description of original sandbox.
	Description *string `json:"description,omitempty"`

	// IsFrozen Sandbox frozen status. When true, edits to the sandbox are restricted. Defaults to frozen status of the original sandbox.
	IsFrozen *bool `json:"is_frozen,omitempty"`

	// Path Path to the collection where the new sandbox should be stored. Defaults to "/". If no collection exists at the given path, it will be created.
	Path *string `json:"path,omitempty"`

	// Privacy Sandbox privacy. 0 for public, 1 for unlisted, and 2 for private. Subject to the minimum privacy restrictions of the workspace. Defaults to the privacy of the original sandbox.
	Privacy *int `json:"privacy,omitempty"`

	// StartOptions Optional VM start configuration. If provided, the sandbox VM will be started immediately after creation.
	StartOptions *struct {
		// AutomaticWakeupConfig Configuration for when the VM should automatically wake up from hibernation
		AutomaticWakeupConfig *struct {
			// Http Whether the VM should automatically wake up on HTTP requests (excludes WebSocket requests)
			Http *bool `json:"http,omitempty"`

			// Websocket Whether the VM should automatically wake up on WebSocket connections
			Websocket *bool `json:"websocket,omitempty"`
		} `json:"automatic_wakeup_config,omitempty"`

		// HibernationTimeoutSeconds The time in seconds after which the VM will hibernate due to inactivity.
		// Must be a positive integer between 1 and 86400 (24 hours).
		// Defaults to 300 seconds (5 minutes) if not specified.
		HibernationTimeoutSeconds *int `json:"hibernation_timeout_seconds,omitempty"`

		// Ipcountry This determines in which cluster, closest to the given country the VM will be started in. The format is ISO-3166-1 alpha-2. If not set, the VM will be started closest to the caller of this API. This will only be applied when a VM is run for the first time, and will only serve as a hint (e.g. if the template of this sandbox runs in EU cluster, this sandbox will also run in the EU cluster).
		Ipcountry *string `json:"ipcountry,omitempty"`

		// Tier Determines which specs to start the VM with. If not specified, the VM will start with the default specs for the workspace.
		//
		// You can only specify a VM tier when starting a VM that is inside your workspace. Specifying a VM tier for someone else's sandbox will return an error.
		//
		// Not all tiers will be available depending on the workspace subscription status, and higher tiers incur higher costs. Please see codesandbox.io/pricing for details on specs and costs.
		Tier *interface{} `json:"tier,omitempty"`
	} `json:"start_options,omitempty"`

	// Tags Tags to set on the new sandbox, if any. Will not inherit tags from the source sandbox.
	Tags *[]string `json:"tags,omitempty"`

	// Title Sandbox title. Maximum 255 characters. Defaults to title of original sandbox with (forked).
	Title *string `json:"title,omitempty"`
}

// SandboxForkResponse defines model for SandboxForkResponse.
type SandboxForkResponse struct {
	Data *struct {
		Alias string `json:"alias"`
		Id    string `json:"id"`

		// StartResponse VM start response. Only present when start_options were provided in the request.
		StartResponse *struct {
			BootupType            string `json:"bootup_type"`
			Cluster               string `json:"cluster"`
			Id                    string `json:"id"`
			LatestPitcherVersion  string `json:"latest_pitcher_version"`
			PitcherManagerVersion string `json:"pitcher_manager_version"`
			PitcherToken          string `json:"pitcher_token"`
			PitcherUrl            string `json:"pitcher_url"`
			PitcherVersion        string `json:"pitcher_version"`
			ReconnectToken        string `json:"reconnect_token"`
			UserWorkspacePath     string `json:"user_workspace_path"`
			WorkspacePath         string `json:"workspace_path"`
		} `json:"start_response"`
		Title *string `json:"title"`
	} `json:"data,omitempty"`
	Errors  *[]SandboxForkResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                              `json:"success,omitempty"`
}

// SandboxForkResponseErrors0 defines model for .
type SandboxForkResponseErrors0 = string

// SandboxForkResponseErrors1 defines model for .
type SandboxForkResponseErrors1 map[string]interface{}

// SandboxForkResponse_Errors_Item defines model for SandboxForkResponse.errors.Item.
type SandboxForkResponse_Errors_Item struct {
	union json.RawMessage
}

// SandboxGetResponse defines model for SandboxGetResponse.
type SandboxGetResponse struct {
	Data    *Sandbox                          `json:"data,omitempty"`
	Errors  *[]SandboxGetResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                             `json:"success,omitempty"`
}

// SandboxGetResponseErrors0 defines model for .
type SandboxGetResponseErrors0 = string

// SandboxGetResponseErrors1 defines model for .
type SandboxGetResponseErrors1 map[string]interface{}

// SandboxGetResponse_Errors_Item defines model for SandboxGetResponse.errors.Item.
type SandboxGetResponse_Errors_Item struct {
	union json.RawMessage
}

// SandboxListResponse defines model for SandboxListResponse.
type SandboxListResponse struct {
	Data *struct {
		Pagination struct {
			CurrentPage int `json:"current_page"`

			// NextPage The number of the next page, if any. If `null`, the current page is the last page of records.
			NextPage     *int `json:"next_page"`
			TotalRecords int  `json:"total_records"`
		} `json:"pagination"`
		Sandboxes []Sandbox `json:"sandboxes"`
	} `json:"data,omitempty"`
	Errors  *[]SandboxListResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                              `json:"success,omitempty"`
}

// SandboxListResponseErrors0 defines model for .
type SandboxListResponseErrors0 = string

// SandboxListResponseErrors1 defines model for .
type SandboxListResponseErrors1 map[string]interface{}

// SandboxListResponse_Errors_Item defines model for SandboxListResponse.errors.Item.
type SandboxListResponse_Errors_Item struct {
	union json.RawMessage
}

// TemplateCreateRequest defines model for TemplateCreateRequest.
type TemplateCreateRequest struct {
	// Description Template description. Maximum 255 characters. Defaults to description of original sandbox.
	Description *string `json:"description,omitempty"`

	// ForkOf Short ID of the sandbox to fork.
	ForkOf string `json:"forkOf"`

	// Tags Tags to set on the new sandbox, if any. Will not inherit tags from the source sandbox.
	Tags *[]string `json:"tags,omitempty"`

	// Title Template title. Maximum 255 characters. Defaults to title of original sandbox with (forked).
	Title *string `json:"title,omitempty"`
}

// TemplateCreateResponse defines model for TemplateCreateResponse.
type TemplateCreateResponse struct {
	Data *struct {
		Sandboxes []struct {
			Cluster string `json:"cluster"`
			Id      string `json:"id"`
		} `json:"sandboxes"`
		Tag string `json:"tag"`
	} `json:"data,omitempty"`
	Errors  *[]TemplateCreateResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                                 `json:"success,omitempty"`
}

// TemplateCreateResponseErrors0 defines model for .
type TemplateCreateResponseErrors0 = string

// TemplateCreateResponseErrors1 defines model for .
type TemplateCreateResponseErrors1 map[string]interface{}

// TemplateCreateResponse_Errors_Item defines model for TemplateCreateResponse.errors.Item.
type TemplateCreateResponse_Errors_Item struct {
	union json.RawMessage
}

// TokenCreateRequest defines model for TokenCreateRequest.
type TokenCreateRequest struct {
	// DefaultVersion API Version to use, formatted as YYYY-MM-DD. Defaults to the latest version at time of creation.
	DefaultVersion *openapi_types.Date `json:"default_version"`

	// Description Description of this token, for instance where it will be used.
	Description *string `json:"description,omitempty"`

	// ExpiresAt UTC Timestamp until when this token is valid. Omitting this field will create a token without an expiry.
	ExpiresAt *time.Time `json:"expires_at"`

	// Scopes Which scopes to grant this token. The given scopes will replace the current scopes, revoking any that are no longer present in the list.
	Scopes *[]interface{} `json:"scopes,omitempty"`
}

// TokenCreateResponse defines model for TokenCreateResponse.
type TokenCreateResponse struct {
	Data *struct {
		Description *string  `json:"description"`
		ExpiresAt   *string  `json:"expires_at"`
		Scopes      []string `json:"scopes"`
		TeamId      string   `json:"team_id"`
		Token       string   `json:"token"`
		TokenId     string   `json:"token_id"`
	} `json:"data,omitempty"`
	Errors  *[]TokenCreateResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                              `json:"success,omitempty"`
}

// TokenCreateResponseErrors0 defines model for .
type TokenCreateResponseErrors0 = string

// TokenCreateResponseErrors1 defines model for .
type TokenCreateResponseErrors1 map[string]interface{}

// TokenCreateResponse_Errors_Item defines model for TokenCreateResponse.errors.Item.
type TokenCreateResponse_Errors_Item struct {
	union json.RawMessage
}

// TokenUpdateRequest Updateable fields for API Tokens. Omitting a field will not update it; explicitly passing null or an empty list will clear the value.
type TokenUpdateRequest struct {
	// DefaultVersion API Version to use, formatted as YYYY-MM-DD
	DefaultVersion *openapi_types.Date `json:"default_version"`

	// Description Description of this token, for instance where it will be used.
	Description *string `json:"description"`

	// ExpiresAt Expiry time of this token. Cannot be set in the past, and cannot be changed for tokens that have already expired. Pass null to make this token never expire.
	ExpiresAt *time.Time `json:"expires_at"`

	// Scopes Which scopes to grant this token. The given scopes will replace the current scopes, revoking any that are no longer present in the list.
	Scopes *[]interface{} `json:"scopes,omitempty"`
}

// TokenUpdateResponse defines model for TokenUpdateResponse.
type TokenUpdateResponse struct {
	Data *struct {
		Description *string    `json:"description"`
		ExpiresAt   *time.Time `json:"expires_at"`
		Scopes      []string   `json:"scopes"`
		TeamId      string     `json:"team_id"`
		TokenId     string     `json:"token_id"`
	} `json:"data,omitempty"`
	Errors  *[]TokenUpdateResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                              `json:"success,omitempty"`
}

// TokenUpdateResponseErrors0 defines model for .
type TokenUpdateResponseErrors0 = string

// TokenUpdateResponseErrors1 defines model for .
type TokenUpdateResponseErrors1 map[string]interface{}

// TokenUpdateResponse_Errors_Item defines model for TokenUpdateResponse.errors.Item.
type TokenUpdateResponse_Errors_Item struct {
	union json.RawMessage
}

// VMAssignTagAliasRequest Assign a tag alias to a VM
type VMAssignTagAliasRequest struct {
	TagId string `json:"tag_id"`
}

// VMAssignTagAliasResponse defines model for VMAssignTagAliasResponse.
type VMAssignTagAliasResponse struct {
	Data *struct {
		Alias      string `json:"alias"`
		Namespace  string `json:"namespace"`
		TagAliasId string `json:"tag_alias_id"`
		TagId      string `json:"tag_id"`
		TeamId     string `json:"team_id"`
	} `json:"data,omitempty"`
	Errors  *[]VMAssignTagAliasResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                                   `json:"success,omitempty"`
}

// VMAssignTagAliasResponseErrors0 defines model for .
type VMAssignTagAliasResponseErrors0 = string

// VMAssignTagAliasResponseErrors1 defines model for .
type VMAssignTagAliasResponseErrors1 map[string]interface{}

// VMAssignTagAliasResponse_Errors_Item defines model for VMAssignTagAliasResponse.errors.Item.
type VMAssignTagAliasResponse_Errors_Item struct {
	union json.RawMessage
}

// VMCreateSessionRequest defines model for VMCreateSessionRequest.
type VMCreateSessionRequest struct {
	// GitAccessToken GitHub token for the session
	GitAccessToken *string `json:"git_access_token,omitempty"`

	// GitUserEmail Git user email to configure for this session
	GitUserEmail *string `json:"git_user_email,omitempty"`

	// GitUserName Git user name to configure for this session
	GitUserName *string `json:"git_user_name,omitempty"`

	// Permission Permission level for the session
	Permission VMCreateSessionRequestPermission `json:"permission"`

	// SessionId Unique identifier for the session
	SessionId string `json:"session_id"`
}

// VMCreateSessionRequestPermission Permission level for the session
type VMCreateSessionRequestPermission string

// VMCreateSessionResponse defines model for VMCreateSessionResponse.
type VMCreateSessionResponse struct {
	Data *struct {
		// Capabilities List of capabilities that Pitcher has
		Capabilities []string `json:"capabilities"`

		// Permissions The permissions of the current session
		Permissions map[string]interface{} `json:"permissions"`

		// PitcherToken Token to authenticate with Pitcher (the agent running inside the VM)
		PitcherToken string `json:"pitcher_token"`

		// PitcherUrl WebSocket URL to connect to Pitcher
		PitcherUrl string `json:"pitcher_url"`

		// UserWorkspacePath Path to the user's workspace in the VM
		UserWorkspacePath string `json:"user_workspace_path"`

		// Username The Linux username created for this session
		Username string `json:"username"`
	} `json:"data,omitempty"`
	Errors  *[]VMCreateSessionResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                                  `json:"success,omitempty"`
}

// VMCreateSessionResponseErrors0 defines model for .
type VMCreateSessionResponseErrors0 = string

// VMCreateSessionResponseErrors1 defines model for .
type VMCreateSessionResponseErrors1 map[string]interface{}

// VMCreateSessionResponse_Errors_Item defines model for VMCreateSessionResponse.errors.Item.
type VMCreateSessionResponse_Errors_Item struct {
	union json.RawMessage
}

// VMCreateTagRequest Create a tag for a list of VM IDs
type VMCreateTagRequest struct {
	VmIds []string `json:"vm_ids"`
}

// VMCreateTagResponse defines model for VMCreateTagResponse.
type VMCreateTagResponse struct {
	Data *struct {
		TagId string `json:"tag_id"`
	} `json:"data,omitempty"`
	Errors  *[]VMCreateTagResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                              `json:"success,omitempty"`
}

// VMCreateTagResponseErrors0 defines model for .
type VMCreateTagResponseErrors0 = string

// VMCreateTagResponseErrors1 defines model for .
type VMCreateTagResponseErrors1 map[string]interface{}

// VMCreateTagResponse_Errors_Item defines model for VMCreateTagResponse.errors.Item.
type VMCreateTagResponse_Errors_Item struct {
	union json.RawMessage
}

// VMHibernateRequest defines model for VMHibernateRequest.
type VMHibernateRequest = interface{}

// VMHibernateResponse defines model for VMHibernateResponse.
type VMHibernateResponse struct {
	Data    *map[string]interface{}            `json:"data,omitempty"`
	Errors  *[]VMHibernateResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                              `json:"success,omitempty"`
}

// VMHibernateResponseErrors0 defines model for .
type VMHibernateResponseErrors0 = string

// VMHibernateResponseErrors1 defines model for .
type VMHibernateResponseErrors1 map[string]interface{}

// VMHibernateResponse_Errors_Item defines model for VMHibernateResponse.errors.Item.
type VMHibernateResponse_Errors_Item struct {
	union json.RawMessage
}

// VMListClustersResponse defines model for VMListClustersResponse.
type VMListClustersResponse struct {
	Data *struct {
		Clusters []struct {
			Host string `json:"host"`
			Slug string `json:"slug"`
		} `json:"clusters"`
	} `json:"data,omitempty"`
	Errors  *[]VMListClustersResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                                 `json:"success,omitempty"`
}

// VMListClustersResponseErrors0 defines model for .
type VMListClustersResponseErrors0 = string

// VMListClustersResponseErrors1 defines model for .
type VMListClustersResponseErrors1 map[string]interface{}

// VMListClustersResponse_Errors_Item defines model for VMListClustersResponse.errors.Item.
type VMListClustersResponse_Errors_Item struct {
	union json.RawMessage
}

// VMListRunningVMsResponse defines model for VMListRunningVMsResponse.
type VMListRunningVMsResponse struct {
	Data *struct {
		ConcurrentVmCount int `json:"concurrent_vm_count"`
		ConcurrentVmLimit int `json:"concurrent_vm_limit"`
		Vms               []struct {
			CreditBasis      *string `json:"credit_basis,omitempty"`
			Id               *string `json:"id,omitempty"`
			LastActiveAt     *int    `json:"last_active_at,omitempty"`
			SessionStartedAt *int    `json:"session_started_at,omitempty"`
			Specs            *struct {
				Cpu     *int `json:"cpu,omitempty"`
				Memory  *int `json:"memory,omitempty"`
				Storage *int `json:"storage,omitempty"`
			} `json:"specs,omitempty"`
		} `json:"vms"`
	} `json:"data,omitempty"`
	Errors  *[]VMListRunningVMsResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                                   `json:"success,omitempty"`
}

// VMListRunningVMsResponseErrors0 defines model for .
type VMListRunningVMsResponseErrors0 = string

// VMListRunningVMsResponseErrors1 defines model for .
type VMListRunningVMsResponseErrors1 map[string]interface{}

// VMListRunningVMsResponse_Errors_Item defines model for VMListRunningVMsResponse.errors.Item.
type VMListRunningVMsResponse_Errors_Item struct {
	union json.RawMessage
}

// VMShutdownRequest defines model for VMShutdownRequest.
type VMShutdownRequest = interface{}

// VMShutdownResponse defines model for VMShutdownResponse.
type VMShutdownResponse struct {
	Data    *map[string]interface{}           `json:"data,omitempty"`
	Errors  *[]VMShutdownResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                             `json:"success,omitempty"`
}

// VMShutdownResponseErrors0 defines model for .
type VMShutdownResponseErrors0 = string

// VMShutdownResponseErrors1 defines model for .
type VMShutdownResponseErrors1 map[string]interface{}

// VMShutdownResponse_Errors_Item defines model for VMShutdownResponse.errors.Item.
type VMShutdownResponse_Errors_Item struct {
	union json.RawMessage
}

// VMStartRequest defines model for VMStartRequest.
type VMStartRequest struct {
	// AutomaticWakeupConfig Configuration for when the VM should automatically wake up from hibernation
	AutomaticWakeupConfig *struct {
		// Http Whether the VM should automatically wake up on HTTP requests (excludes WebSocket requests)
		Http *bool `json:"http,omitempty"`

		// Websocket Whether the VM should automatically wake up on WebSocket connections
		Websocket *bool `json:"websocket,omitempty"`
	} `json:"automatic_wakeup_config,omitempty"`

	// HibernationTimeoutSeconds The time in seconds after which the VM will hibernate due to inactivity.
	// Must be a positive integer between 1 and 86400 (24 hours).
	// Defaults to 300 seconds (5 minutes) if not specified.
	HibernationTimeoutSeconds *int `json:"hibernation_timeout_seconds,omitempty"`

	// Ipcountry This determines in which cluster, closest to the given country the VM will be started in. The format is ISO-3166-1 alpha-2. If not set, the VM will be started closest to the caller of this API. This will only be applied when a VM is run for the first time, and will only serve as a hint (e.g. if the template of this sandbox runs in EU cluster, this sandbox will also run in the EU cluster).
	Ipcountry *string `json:"ipcountry,omitempty"`

	// Tier Determines which specs to start the VM with. If not specified, the VM will start with the default specs for the workspace.
	//
	// You can only specify a VM tier when starting a VM that is inside your workspace. Specifying a VM tier for someone else's sandbox will return an error.
	//
	// Not all tiers will be available depending on the workspace subscription status, and higher tiers incur higher costs. Please see codesandbox.io/pricing for details on specs and costs.
	Tier *interface{} `json:"tier,omitempty"`
}

// VMStartResponse defines model for VMStartResponse.
type VMStartResponse struct {
	Data *struct {
		BootupType            string `json:"bootup_type"`
		Cluster               string `json:"cluster"`
		Id                    string `json:"id"`
		LatestPitcherVersion  string `json:"latest_pitcher_version"`
		PitcherManagerVersion string `json:"pitcher_manager_version"`
		PitcherToken          string `json:"pitcher_token"`
		PitcherUrl            string `json:"pitcher_url"`
		PitcherVersion        string `json:"pitcher_version"`
		ReconnectToken        string `json:"reconnect_token"`
		UserWorkspacePath     string `json:"user_workspace_path"`
		WorkspacePath         string `json:"workspace_path"`
	} `json:"data,omitempty"`
	Errors  *[]VMStartResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                          `json:"success,omitempty"`
}

// VMStartResponseErrors0 defines model for .
type VMStartResponseErrors0 = string

// VMStartResponseErrors1 defines model for .
type VMStartResponseErrors1 map[string]interface{}

// VMStartResponse_Errors_Item defines model for VMStartResponse.errors.Item.
type VMStartResponse_Errors_Item struct {
	union json.RawMessage
}

// VMUpdateHibernationTimeoutRequest defines model for VMUpdateHibernationTimeoutRequest.
type VMUpdateHibernationTimeoutRequest struct {
	// HibernationTimeoutSeconds The new hibernation timeout in seconds.
	//
	// Must be greater than 0 and less than or equal to 86400 (24 hours).
	HibernationTimeoutSeconds int `json:"hibernation_timeout_seconds"`
}

// VMUpdateHibernationTimeoutResponse defines model for VMUpdateHibernationTimeoutResponse.
type VMUpdateHibernationTimeoutResponse struct {
	Data *struct {
		HibernationTimeoutSeconds int    `json:"hibernation_timeout_seconds"`
		Id                        string `json:"id"`
	} `json:"data,omitempty"`
	Errors  *[]VMUpdateHibernationTimeoutResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                                             `json:"success,omitempty"`
}

// VMUpdateHibernationTimeoutResponseErrors0 defines model for .
type VMUpdateHibernationTimeoutResponseErrors0 = string

// VMUpdateHibernationTimeoutResponseErrors1 defines model for .
type VMUpdateHibernationTimeoutResponseErrors1 map[string]interface{}

// VMUpdateHibernationTimeoutResponse_Errors_Item defines model for VMUpdateHibernationTimeoutResponse.errors.Item.
type VMUpdateHibernationTimeoutResponse_Errors_Item struct {
	union json.RawMessage
}

// VMUpdateSpecsRequest defines model for VMUpdateSpecsRequest.
type VMUpdateSpecsRequest struct {
	// Tier Determines which specs to update the VM with.
	//
	// Not all tiers will be available depending on the workspace subscription status, and higher tiers incur higher costs. Please see codesandbox.io/pricing for details on specs and costs.
	Tier interface{} `json:"tier"`
}

// VMUpdateSpecsResponse defines model for VMUpdateSpecsResponse.
type VMUpdateSpecsResponse struct {
	Data *struct {
		Id   string `json:"id"`
		Tier string `json:"tier"`
	} `json:"data,omitempty"`
	Errors  *[]VMUpdateSpecsResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                                `json:"success,omitempty"`
}

// VMUpdateSpecsResponseErrors0 defines model for .
type VMUpdateSpecsResponseErrors0 = string

// VMUpdateSpecsResponseErrors1 defines model for .
type VMUpdateSpecsResponseErrors1 map[string]interface{}

// VMUpdateSpecsResponse_Errors_Item defines model for VMUpdateSpecsResponse.errors.Item.
type VMUpdateSpecsResponse_Errors_Item struct {
	union json.RawMessage
}

// WorkspaceCreateRequest defines model for WorkspaceCreateRequest.
type WorkspaceCreateRequest struct {
	// Name Name for the new workspace. Maximum length 64 characters.
	Name string `json:"name"`
}

// WorkspaceCreateResponse defines model for WorkspaceCreateResponse.
type WorkspaceCreateResponse struct {
	Data *struct {
		Id   string `json:"id"`
		Name string `json:"name"`
	} `json:"data,omitempty"`
	Errors  *[]WorkspaceCreateResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                                  `json:"success,omitempty"`
}

// WorkspaceCreateResponseErrors0 defines model for .
type WorkspaceCreateResponseErrors0 = string

// WorkspaceCreateResponseErrors1 defines model for .
type WorkspaceCreateResponseErrors1 map[string]interface{}

// WorkspaceCreateResponse_Errors_Item defines model for WorkspaceCreateResponse.errors.Item.
type WorkspaceCreateResponse_Errors_Item struct {
	union json.RawMessage
}

// SandboxlistParams defines parameters for Sandboxlist.
type SandboxlistParams struct {
	// Tags Comma-separated list of tags to filter by
	Tags *string `form:"tags,omitempty" json:"tags,omitempty"`

	// OrderBy Field to order results by
	OrderBy *interface{} `form:"order_by,omitempty" json:"order_by,omitempty"`

	// Direction Order direction
	Direction *interface{} `form:"direction,omitempty" json:"direction,omitempty"`

	// PageSize Maximum number of sandboxes to return in a single response
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// Page Page number to return
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Status If true, only returns VMs for which a heartbeat was received in the last 30 seconds.
	Status *interface{} `form:"status,omitempty" json:"status,omitempty"`
}

// WorkspacecreateJSONRequestBody defines body for Workspacecreate for application/json ContentType.
type WorkspacecreateJSONRequestBody = WorkspaceCreateRequest

// TokencreateJSONRequestBody defines body for Tokencreate for application/json ContentType.
type TokencreateJSONRequestBody = TokenCreateRequest

// TokenupdateJSONRequestBody defines body for Tokenupdate for application/json ContentType.
type TokenupdateJSONRequestBody = TokenUpdateRequest

// SandboxcreateJSONRequestBody defines body for Sandboxcreate for application/json ContentType.
type SandboxcreateJSONRequestBody = SandboxCreateRequest

// SandboxforkJSONRequestBody defines body for Sandboxfork for application/json ContentType.
type SandboxforkJSONRequestBody = SandboxForkRequest

// PreviewTokencreateJSONRequestBody defines body for PreviewTokencreate for application/json ContentType.
type PreviewTokencreateJSONRequestBody = PreviewTokenCreateRequest

// PreviewTokenupdateJSONRequestBody defines body for PreviewTokenupdate for application/json ContentType.
type PreviewTokenupdateJSONRequestBody = PreviewTokenUpdateRequest

// TemplatescreateJSONRequestBody defines body for Templatescreate for application/json ContentType.
type TemplatescreateJSONRequestBody = TemplateCreateRequest

// VmassignTagAliasJSONRequestBody defines body for VmassignTagAlias for application/json ContentType.
type VmassignTagAliasJSONRequestBody = VMAssignTagAliasRequest

// VmcreateTagJSONRequestBody defines body for VmcreateTag for application/json ContentType.
type VmcreateTagJSONRequestBody = VMCreateTagRequest

// VmhibernateJSONRequestBody defines body for Vmhibernate for application/json ContentType.
type VmhibernateJSONRequestBody = VMHibernateRequest

// VmupdateHibernationTimeoutJSONRequestBody defines body for VmupdateHibernationTimeout for application/json ContentType.
type VmupdateHibernationTimeoutJSONRequestBody = VMUpdateHibernationTimeoutRequest

// VmcreateSessionJSONRequestBody defines body for VmcreateSession for application/json ContentType.
type VmcreateSessionJSONRequestBody = VMCreateSessionRequest

// VmshutdownJSONRequestBody defines body for Vmshutdown for application/json ContentType.
type VmshutdownJSONRequestBody = VMShutdownRequest

// VmupdateSpecsJSONRequestBody defines body for VmupdateSpecs for application/json ContentType.
type VmupdateSpecsJSONRequestBody = VMUpdateSpecsRequest

// VmstartJSONRequestBody defines body for Vmstart for application/json ContentType.
type VmstartJSONRequestBody = VMStartRequest

// VmupdateSpecs2JSONRequestBody defines body for VmupdateSpecs2 for application/json ContentType.
type VmupdateSpecs2JSONRequestBody = VMUpdateSpecsRequest

// PreviewHostcreateJSONRequestBody defines body for PreviewHostcreate for application/json ContentType.
type PreviewHostcreateJSONRequestBody = PreviewHostRequest

// PreviewHostupdateJSONRequestBody defines body for PreviewHostupdate for application/json ContentType.
type PreviewHostupdateJSONRequestBody = PreviewHostRequest

// AsPreviewHostListResponseErrors0 returns the union data inside the PreviewHostListResponse_Errors_Item as a PreviewHostListResponseErrors0
func (t PreviewHostListResponse_Errors_Item) AsPreviewHostListResponseErrors0() (PreviewHostListResponseErrors0, error) {
	var body PreviewHostListResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreviewHostListResponseErrors0 overwrites any union data inside the PreviewHostListResponse_Errors_Item as the provided PreviewHostListResponseErrors0
func (t *PreviewHostListResponse_Errors_Item) FromPreviewHostListResponseErrors0(v PreviewHostListResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreviewHostListResponseErrors0 performs a merge with any union data inside the PreviewHostListResponse_Errors_Item, using the provided PreviewHostListResponseErrors0
func (t *PreviewHostListResponse_Errors_Item) MergePreviewHostListResponseErrors0(v PreviewHostListResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPreviewHostListResponseErrors1 returns the union data inside the PreviewHostListResponse_Errors_Item as a PreviewHostListResponseErrors1
func (t PreviewHostListResponse_Errors_Item) AsPreviewHostListResponseErrors1() (PreviewHostListResponseErrors1, error) {
	var body PreviewHostListResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreviewHostListResponseErrors1 overwrites any union data inside the PreviewHostListResponse_Errors_Item as the provided PreviewHostListResponseErrors1
func (t *PreviewHostListResponse_Errors_Item) FromPreviewHostListResponseErrors1(v PreviewHostListResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreviewHostListResponseErrors1 performs a merge with any union data inside the PreviewHostListResponse_Errors_Item, using the provided PreviewHostListResponseErrors1
func (t *PreviewHostListResponse_Errors_Item) MergePreviewHostListResponseErrors1(v PreviewHostListResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PreviewHostListResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PreviewHostListResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPreviewTokenCreateResponseErrors0 returns the union data inside the PreviewTokenCreateResponse_Errors_Item as a PreviewTokenCreateResponseErrors0
func (t PreviewTokenCreateResponse_Errors_Item) AsPreviewTokenCreateResponseErrors0() (PreviewTokenCreateResponseErrors0, error) {
	var body PreviewTokenCreateResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreviewTokenCreateResponseErrors0 overwrites any union data inside the PreviewTokenCreateResponse_Errors_Item as the provided PreviewTokenCreateResponseErrors0
func (t *PreviewTokenCreateResponse_Errors_Item) FromPreviewTokenCreateResponseErrors0(v PreviewTokenCreateResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreviewTokenCreateResponseErrors0 performs a merge with any union data inside the PreviewTokenCreateResponse_Errors_Item, using the provided PreviewTokenCreateResponseErrors0
func (t *PreviewTokenCreateResponse_Errors_Item) MergePreviewTokenCreateResponseErrors0(v PreviewTokenCreateResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPreviewTokenCreateResponseErrors1 returns the union data inside the PreviewTokenCreateResponse_Errors_Item as a PreviewTokenCreateResponseErrors1
func (t PreviewTokenCreateResponse_Errors_Item) AsPreviewTokenCreateResponseErrors1() (PreviewTokenCreateResponseErrors1, error) {
	var body PreviewTokenCreateResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreviewTokenCreateResponseErrors1 overwrites any union data inside the PreviewTokenCreateResponse_Errors_Item as the provided PreviewTokenCreateResponseErrors1
func (t *PreviewTokenCreateResponse_Errors_Item) FromPreviewTokenCreateResponseErrors1(v PreviewTokenCreateResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreviewTokenCreateResponseErrors1 performs a merge with any union data inside the PreviewTokenCreateResponse_Errors_Item, using the provided PreviewTokenCreateResponseErrors1
func (t *PreviewTokenCreateResponse_Errors_Item) MergePreviewTokenCreateResponseErrors1(v PreviewTokenCreateResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PreviewTokenCreateResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PreviewTokenCreateResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPreviewTokenListResponseErrors0 returns the union data inside the PreviewTokenListResponse_Errors_Item as a PreviewTokenListResponseErrors0
func (t PreviewTokenListResponse_Errors_Item) AsPreviewTokenListResponseErrors0() (PreviewTokenListResponseErrors0, error) {
	var body PreviewTokenListResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreviewTokenListResponseErrors0 overwrites any union data inside the PreviewTokenListResponse_Errors_Item as the provided PreviewTokenListResponseErrors0
func (t *PreviewTokenListResponse_Errors_Item) FromPreviewTokenListResponseErrors0(v PreviewTokenListResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreviewTokenListResponseErrors0 performs a merge with any union data inside the PreviewTokenListResponse_Errors_Item, using the provided PreviewTokenListResponseErrors0
func (t *PreviewTokenListResponse_Errors_Item) MergePreviewTokenListResponseErrors0(v PreviewTokenListResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPreviewTokenListResponseErrors1 returns the union data inside the PreviewTokenListResponse_Errors_Item as a PreviewTokenListResponseErrors1
func (t PreviewTokenListResponse_Errors_Item) AsPreviewTokenListResponseErrors1() (PreviewTokenListResponseErrors1, error) {
	var body PreviewTokenListResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreviewTokenListResponseErrors1 overwrites any union data inside the PreviewTokenListResponse_Errors_Item as the provided PreviewTokenListResponseErrors1
func (t *PreviewTokenListResponse_Errors_Item) FromPreviewTokenListResponseErrors1(v PreviewTokenListResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreviewTokenListResponseErrors1 performs a merge with any union data inside the PreviewTokenListResponse_Errors_Item, using the provided PreviewTokenListResponseErrors1
func (t *PreviewTokenListResponse_Errors_Item) MergePreviewTokenListResponseErrors1(v PreviewTokenListResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PreviewTokenListResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PreviewTokenListResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPreviewTokenRevokeAllResponseErrors0 returns the union data inside the PreviewTokenRevokeAllResponse_Errors_Item as a PreviewTokenRevokeAllResponseErrors0
func (t PreviewTokenRevokeAllResponse_Errors_Item) AsPreviewTokenRevokeAllResponseErrors0() (PreviewTokenRevokeAllResponseErrors0, error) {
	var body PreviewTokenRevokeAllResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreviewTokenRevokeAllResponseErrors0 overwrites any union data inside the PreviewTokenRevokeAllResponse_Errors_Item as the provided PreviewTokenRevokeAllResponseErrors0
func (t *PreviewTokenRevokeAllResponse_Errors_Item) FromPreviewTokenRevokeAllResponseErrors0(v PreviewTokenRevokeAllResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreviewTokenRevokeAllResponseErrors0 performs a merge with any union data inside the PreviewTokenRevokeAllResponse_Errors_Item, using the provided PreviewTokenRevokeAllResponseErrors0
func (t *PreviewTokenRevokeAllResponse_Errors_Item) MergePreviewTokenRevokeAllResponseErrors0(v PreviewTokenRevokeAllResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPreviewTokenRevokeAllResponseErrors1 returns the union data inside the PreviewTokenRevokeAllResponse_Errors_Item as a PreviewTokenRevokeAllResponseErrors1
func (t PreviewTokenRevokeAllResponse_Errors_Item) AsPreviewTokenRevokeAllResponseErrors1() (PreviewTokenRevokeAllResponseErrors1, error) {
	var body PreviewTokenRevokeAllResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreviewTokenRevokeAllResponseErrors1 overwrites any union data inside the PreviewTokenRevokeAllResponse_Errors_Item as the provided PreviewTokenRevokeAllResponseErrors1
func (t *PreviewTokenRevokeAllResponse_Errors_Item) FromPreviewTokenRevokeAllResponseErrors1(v PreviewTokenRevokeAllResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreviewTokenRevokeAllResponseErrors1 performs a merge with any union data inside the PreviewTokenRevokeAllResponse_Errors_Item, using the provided PreviewTokenRevokeAllResponseErrors1
func (t *PreviewTokenRevokeAllResponse_Errors_Item) MergePreviewTokenRevokeAllResponseErrors1(v PreviewTokenRevokeAllResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PreviewTokenRevokeAllResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PreviewTokenRevokeAllResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPreviewTokenUpdateResponseErrors0 returns the union data inside the PreviewTokenUpdateResponse_Errors_Item as a PreviewTokenUpdateResponseErrors0
func (t PreviewTokenUpdateResponse_Errors_Item) AsPreviewTokenUpdateResponseErrors0() (PreviewTokenUpdateResponseErrors0, error) {
	var body PreviewTokenUpdateResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreviewTokenUpdateResponseErrors0 overwrites any union data inside the PreviewTokenUpdateResponse_Errors_Item as the provided PreviewTokenUpdateResponseErrors0
func (t *PreviewTokenUpdateResponse_Errors_Item) FromPreviewTokenUpdateResponseErrors0(v PreviewTokenUpdateResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreviewTokenUpdateResponseErrors0 performs a merge with any union data inside the PreviewTokenUpdateResponse_Errors_Item, using the provided PreviewTokenUpdateResponseErrors0
func (t *PreviewTokenUpdateResponse_Errors_Item) MergePreviewTokenUpdateResponseErrors0(v PreviewTokenUpdateResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPreviewTokenUpdateResponseErrors1 returns the union data inside the PreviewTokenUpdateResponse_Errors_Item as a PreviewTokenUpdateResponseErrors1
func (t PreviewTokenUpdateResponse_Errors_Item) AsPreviewTokenUpdateResponseErrors1() (PreviewTokenUpdateResponseErrors1, error) {
	var body PreviewTokenUpdateResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreviewTokenUpdateResponseErrors1 overwrites any union data inside the PreviewTokenUpdateResponse_Errors_Item as the provided PreviewTokenUpdateResponseErrors1
func (t *PreviewTokenUpdateResponse_Errors_Item) FromPreviewTokenUpdateResponseErrors1(v PreviewTokenUpdateResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreviewTokenUpdateResponseErrors1 performs a merge with any union data inside the PreviewTokenUpdateResponse_Errors_Item, using the provided PreviewTokenUpdateResponseErrors1
func (t *PreviewTokenUpdateResponse_Errors_Item) MergePreviewTokenUpdateResponseErrors1(v PreviewTokenUpdateResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PreviewTokenUpdateResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PreviewTokenUpdateResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSandboxCreateResponseErrors0 returns the union data inside the SandboxCreateResponse_Errors_Item as a SandboxCreateResponseErrors0
func (t SandboxCreateResponse_Errors_Item) AsSandboxCreateResponseErrors0() (SandboxCreateResponseErrors0, error) {
	var body SandboxCreateResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSandboxCreateResponseErrors0 overwrites any union data inside the SandboxCreateResponse_Errors_Item as the provided SandboxCreateResponseErrors0
func (t *SandboxCreateResponse_Errors_Item) FromSandboxCreateResponseErrors0(v SandboxCreateResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSandboxCreateResponseErrors0 performs a merge with any union data inside the SandboxCreateResponse_Errors_Item, using the provided SandboxCreateResponseErrors0
func (t *SandboxCreateResponse_Errors_Item) MergeSandboxCreateResponseErrors0(v SandboxCreateResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSandboxCreateResponseErrors1 returns the union data inside the SandboxCreateResponse_Errors_Item as a SandboxCreateResponseErrors1
func (t SandboxCreateResponse_Errors_Item) AsSandboxCreateResponseErrors1() (SandboxCreateResponseErrors1, error) {
	var body SandboxCreateResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSandboxCreateResponseErrors1 overwrites any union data inside the SandboxCreateResponse_Errors_Item as the provided SandboxCreateResponseErrors1
func (t *SandboxCreateResponse_Errors_Item) FromSandboxCreateResponseErrors1(v SandboxCreateResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSandboxCreateResponseErrors1 performs a merge with any union data inside the SandboxCreateResponse_Errors_Item, using the provided SandboxCreateResponseErrors1
func (t *SandboxCreateResponse_Errors_Item) MergeSandboxCreateResponseErrors1(v SandboxCreateResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SandboxCreateResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SandboxCreateResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSandboxForkResponseErrors0 returns the union data inside the SandboxForkResponse_Errors_Item as a SandboxForkResponseErrors0
func (t SandboxForkResponse_Errors_Item) AsSandboxForkResponseErrors0() (SandboxForkResponseErrors0, error) {
	var body SandboxForkResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSandboxForkResponseErrors0 overwrites any union data inside the SandboxForkResponse_Errors_Item as the provided SandboxForkResponseErrors0
func (t *SandboxForkResponse_Errors_Item) FromSandboxForkResponseErrors0(v SandboxForkResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSandboxForkResponseErrors0 performs a merge with any union data inside the SandboxForkResponse_Errors_Item, using the provided SandboxForkResponseErrors0
func (t *SandboxForkResponse_Errors_Item) MergeSandboxForkResponseErrors0(v SandboxForkResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSandboxForkResponseErrors1 returns the union data inside the SandboxForkResponse_Errors_Item as a SandboxForkResponseErrors1
func (t SandboxForkResponse_Errors_Item) AsSandboxForkResponseErrors1() (SandboxForkResponseErrors1, error) {
	var body SandboxForkResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSandboxForkResponseErrors1 overwrites any union data inside the SandboxForkResponse_Errors_Item as the provided SandboxForkResponseErrors1
func (t *SandboxForkResponse_Errors_Item) FromSandboxForkResponseErrors1(v SandboxForkResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSandboxForkResponseErrors1 performs a merge with any union data inside the SandboxForkResponse_Errors_Item, using the provided SandboxForkResponseErrors1
func (t *SandboxForkResponse_Errors_Item) MergeSandboxForkResponseErrors1(v SandboxForkResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SandboxForkResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SandboxForkResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSandboxGetResponseErrors0 returns the union data inside the SandboxGetResponse_Errors_Item as a SandboxGetResponseErrors0
func (t SandboxGetResponse_Errors_Item) AsSandboxGetResponseErrors0() (SandboxGetResponseErrors0, error) {
	var body SandboxGetResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSandboxGetResponseErrors0 overwrites any union data inside the SandboxGetResponse_Errors_Item as the provided SandboxGetResponseErrors0
func (t *SandboxGetResponse_Errors_Item) FromSandboxGetResponseErrors0(v SandboxGetResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSandboxGetResponseErrors0 performs a merge with any union data inside the SandboxGetResponse_Errors_Item, using the provided SandboxGetResponseErrors0
func (t *SandboxGetResponse_Errors_Item) MergeSandboxGetResponseErrors0(v SandboxGetResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSandboxGetResponseErrors1 returns the union data inside the SandboxGetResponse_Errors_Item as a SandboxGetResponseErrors1
func (t SandboxGetResponse_Errors_Item) AsSandboxGetResponseErrors1() (SandboxGetResponseErrors1, error) {
	var body SandboxGetResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSandboxGetResponseErrors1 overwrites any union data inside the SandboxGetResponse_Errors_Item as the provided SandboxGetResponseErrors1
func (t *SandboxGetResponse_Errors_Item) FromSandboxGetResponseErrors1(v SandboxGetResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSandboxGetResponseErrors1 performs a merge with any union data inside the SandboxGetResponse_Errors_Item, using the provided SandboxGetResponseErrors1
func (t *SandboxGetResponse_Errors_Item) MergeSandboxGetResponseErrors1(v SandboxGetResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SandboxGetResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SandboxGetResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSandboxListResponseErrors0 returns the union data inside the SandboxListResponse_Errors_Item as a SandboxListResponseErrors0
func (t SandboxListResponse_Errors_Item) AsSandboxListResponseErrors0() (SandboxListResponseErrors0, error) {
	var body SandboxListResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSandboxListResponseErrors0 overwrites any union data inside the SandboxListResponse_Errors_Item as the provided SandboxListResponseErrors0
func (t *SandboxListResponse_Errors_Item) FromSandboxListResponseErrors0(v SandboxListResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSandboxListResponseErrors0 performs a merge with any union data inside the SandboxListResponse_Errors_Item, using the provided SandboxListResponseErrors0
func (t *SandboxListResponse_Errors_Item) MergeSandboxListResponseErrors0(v SandboxListResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSandboxListResponseErrors1 returns the union data inside the SandboxListResponse_Errors_Item as a SandboxListResponseErrors1
func (t SandboxListResponse_Errors_Item) AsSandboxListResponseErrors1() (SandboxListResponseErrors1, error) {
	var body SandboxListResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSandboxListResponseErrors1 overwrites any union data inside the SandboxListResponse_Errors_Item as the provided SandboxListResponseErrors1
func (t *SandboxListResponse_Errors_Item) FromSandboxListResponseErrors1(v SandboxListResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSandboxListResponseErrors1 performs a merge with any union data inside the SandboxListResponse_Errors_Item, using the provided SandboxListResponseErrors1
func (t *SandboxListResponse_Errors_Item) MergeSandboxListResponseErrors1(v SandboxListResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SandboxListResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SandboxListResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTemplateCreateResponseErrors0 returns the union data inside the TemplateCreateResponse_Errors_Item as a TemplateCreateResponseErrors0
func (t TemplateCreateResponse_Errors_Item) AsTemplateCreateResponseErrors0() (TemplateCreateResponseErrors0, error) {
	var body TemplateCreateResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTemplateCreateResponseErrors0 overwrites any union data inside the TemplateCreateResponse_Errors_Item as the provided TemplateCreateResponseErrors0
func (t *TemplateCreateResponse_Errors_Item) FromTemplateCreateResponseErrors0(v TemplateCreateResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTemplateCreateResponseErrors0 performs a merge with any union data inside the TemplateCreateResponse_Errors_Item, using the provided TemplateCreateResponseErrors0
func (t *TemplateCreateResponse_Errors_Item) MergeTemplateCreateResponseErrors0(v TemplateCreateResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTemplateCreateResponseErrors1 returns the union data inside the TemplateCreateResponse_Errors_Item as a TemplateCreateResponseErrors1
func (t TemplateCreateResponse_Errors_Item) AsTemplateCreateResponseErrors1() (TemplateCreateResponseErrors1, error) {
	var body TemplateCreateResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTemplateCreateResponseErrors1 overwrites any union data inside the TemplateCreateResponse_Errors_Item as the provided TemplateCreateResponseErrors1
func (t *TemplateCreateResponse_Errors_Item) FromTemplateCreateResponseErrors1(v TemplateCreateResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTemplateCreateResponseErrors1 performs a merge with any union data inside the TemplateCreateResponse_Errors_Item, using the provided TemplateCreateResponseErrors1
func (t *TemplateCreateResponse_Errors_Item) MergeTemplateCreateResponseErrors1(v TemplateCreateResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TemplateCreateResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TemplateCreateResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTokenCreateResponseErrors0 returns the union data inside the TokenCreateResponse_Errors_Item as a TokenCreateResponseErrors0
func (t TokenCreateResponse_Errors_Item) AsTokenCreateResponseErrors0() (TokenCreateResponseErrors0, error) {
	var body TokenCreateResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTokenCreateResponseErrors0 overwrites any union data inside the TokenCreateResponse_Errors_Item as the provided TokenCreateResponseErrors0
func (t *TokenCreateResponse_Errors_Item) FromTokenCreateResponseErrors0(v TokenCreateResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTokenCreateResponseErrors0 performs a merge with any union data inside the TokenCreateResponse_Errors_Item, using the provided TokenCreateResponseErrors0
func (t *TokenCreateResponse_Errors_Item) MergeTokenCreateResponseErrors0(v TokenCreateResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTokenCreateResponseErrors1 returns the union data inside the TokenCreateResponse_Errors_Item as a TokenCreateResponseErrors1
func (t TokenCreateResponse_Errors_Item) AsTokenCreateResponseErrors1() (TokenCreateResponseErrors1, error) {
	var body TokenCreateResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTokenCreateResponseErrors1 overwrites any union data inside the TokenCreateResponse_Errors_Item as the provided TokenCreateResponseErrors1
func (t *TokenCreateResponse_Errors_Item) FromTokenCreateResponseErrors1(v TokenCreateResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTokenCreateResponseErrors1 performs a merge with any union data inside the TokenCreateResponse_Errors_Item, using the provided TokenCreateResponseErrors1
func (t *TokenCreateResponse_Errors_Item) MergeTokenCreateResponseErrors1(v TokenCreateResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TokenCreateResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TokenCreateResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTokenUpdateResponseErrors0 returns the union data inside the TokenUpdateResponse_Errors_Item as a TokenUpdateResponseErrors0
func (t TokenUpdateResponse_Errors_Item) AsTokenUpdateResponseErrors0() (TokenUpdateResponseErrors0, error) {
	var body TokenUpdateResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTokenUpdateResponseErrors0 overwrites any union data inside the TokenUpdateResponse_Errors_Item as the provided TokenUpdateResponseErrors0
func (t *TokenUpdateResponse_Errors_Item) FromTokenUpdateResponseErrors0(v TokenUpdateResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTokenUpdateResponseErrors0 performs a merge with any union data inside the TokenUpdateResponse_Errors_Item, using the provided TokenUpdateResponseErrors0
func (t *TokenUpdateResponse_Errors_Item) MergeTokenUpdateResponseErrors0(v TokenUpdateResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTokenUpdateResponseErrors1 returns the union data inside the TokenUpdateResponse_Errors_Item as a TokenUpdateResponseErrors1
func (t TokenUpdateResponse_Errors_Item) AsTokenUpdateResponseErrors1() (TokenUpdateResponseErrors1, error) {
	var body TokenUpdateResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTokenUpdateResponseErrors1 overwrites any union data inside the TokenUpdateResponse_Errors_Item as the provided TokenUpdateResponseErrors1
func (t *TokenUpdateResponse_Errors_Item) FromTokenUpdateResponseErrors1(v TokenUpdateResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTokenUpdateResponseErrors1 performs a merge with any union data inside the TokenUpdateResponse_Errors_Item, using the provided TokenUpdateResponseErrors1
func (t *TokenUpdateResponse_Errors_Item) MergeTokenUpdateResponseErrors1(v TokenUpdateResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TokenUpdateResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TokenUpdateResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVMAssignTagAliasResponseErrors0 returns the union data inside the VMAssignTagAliasResponse_Errors_Item as a VMAssignTagAliasResponseErrors0
func (t VMAssignTagAliasResponse_Errors_Item) AsVMAssignTagAliasResponseErrors0() (VMAssignTagAliasResponseErrors0, error) {
	var body VMAssignTagAliasResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMAssignTagAliasResponseErrors0 overwrites any union data inside the VMAssignTagAliasResponse_Errors_Item as the provided VMAssignTagAliasResponseErrors0
func (t *VMAssignTagAliasResponse_Errors_Item) FromVMAssignTagAliasResponseErrors0(v VMAssignTagAliasResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMAssignTagAliasResponseErrors0 performs a merge with any union data inside the VMAssignTagAliasResponse_Errors_Item, using the provided VMAssignTagAliasResponseErrors0
func (t *VMAssignTagAliasResponse_Errors_Item) MergeVMAssignTagAliasResponseErrors0(v VMAssignTagAliasResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVMAssignTagAliasResponseErrors1 returns the union data inside the VMAssignTagAliasResponse_Errors_Item as a VMAssignTagAliasResponseErrors1
func (t VMAssignTagAliasResponse_Errors_Item) AsVMAssignTagAliasResponseErrors1() (VMAssignTagAliasResponseErrors1, error) {
	var body VMAssignTagAliasResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMAssignTagAliasResponseErrors1 overwrites any union data inside the VMAssignTagAliasResponse_Errors_Item as the provided VMAssignTagAliasResponseErrors1
func (t *VMAssignTagAliasResponse_Errors_Item) FromVMAssignTagAliasResponseErrors1(v VMAssignTagAliasResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMAssignTagAliasResponseErrors1 performs a merge with any union data inside the VMAssignTagAliasResponse_Errors_Item, using the provided VMAssignTagAliasResponseErrors1
func (t *VMAssignTagAliasResponse_Errors_Item) MergeVMAssignTagAliasResponseErrors1(v VMAssignTagAliasResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t VMAssignTagAliasResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VMAssignTagAliasResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVMCreateSessionResponseErrors0 returns the union data inside the VMCreateSessionResponse_Errors_Item as a VMCreateSessionResponseErrors0
func (t VMCreateSessionResponse_Errors_Item) AsVMCreateSessionResponseErrors0() (VMCreateSessionResponseErrors0, error) {
	var body VMCreateSessionResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMCreateSessionResponseErrors0 overwrites any union data inside the VMCreateSessionResponse_Errors_Item as the provided VMCreateSessionResponseErrors0
func (t *VMCreateSessionResponse_Errors_Item) FromVMCreateSessionResponseErrors0(v VMCreateSessionResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMCreateSessionResponseErrors0 performs a merge with any union data inside the VMCreateSessionResponse_Errors_Item, using the provided VMCreateSessionResponseErrors0
func (t *VMCreateSessionResponse_Errors_Item) MergeVMCreateSessionResponseErrors0(v VMCreateSessionResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVMCreateSessionResponseErrors1 returns the union data inside the VMCreateSessionResponse_Errors_Item as a VMCreateSessionResponseErrors1
func (t VMCreateSessionResponse_Errors_Item) AsVMCreateSessionResponseErrors1() (VMCreateSessionResponseErrors1, error) {
	var body VMCreateSessionResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMCreateSessionResponseErrors1 overwrites any union data inside the VMCreateSessionResponse_Errors_Item as the provided VMCreateSessionResponseErrors1
func (t *VMCreateSessionResponse_Errors_Item) FromVMCreateSessionResponseErrors1(v VMCreateSessionResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMCreateSessionResponseErrors1 performs a merge with any union data inside the VMCreateSessionResponse_Errors_Item, using the provided VMCreateSessionResponseErrors1
func (t *VMCreateSessionResponse_Errors_Item) MergeVMCreateSessionResponseErrors1(v VMCreateSessionResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t VMCreateSessionResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VMCreateSessionResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVMCreateTagResponseErrors0 returns the union data inside the VMCreateTagResponse_Errors_Item as a VMCreateTagResponseErrors0
func (t VMCreateTagResponse_Errors_Item) AsVMCreateTagResponseErrors0() (VMCreateTagResponseErrors0, error) {
	var body VMCreateTagResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMCreateTagResponseErrors0 overwrites any union data inside the VMCreateTagResponse_Errors_Item as the provided VMCreateTagResponseErrors0
func (t *VMCreateTagResponse_Errors_Item) FromVMCreateTagResponseErrors0(v VMCreateTagResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMCreateTagResponseErrors0 performs a merge with any union data inside the VMCreateTagResponse_Errors_Item, using the provided VMCreateTagResponseErrors0
func (t *VMCreateTagResponse_Errors_Item) MergeVMCreateTagResponseErrors0(v VMCreateTagResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVMCreateTagResponseErrors1 returns the union data inside the VMCreateTagResponse_Errors_Item as a VMCreateTagResponseErrors1
func (t VMCreateTagResponse_Errors_Item) AsVMCreateTagResponseErrors1() (VMCreateTagResponseErrors1, error) {
	var body VMCreateTagResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMCreateTagResponseErrors1 overwrites any union data inside the VMCreateTagResponse_Errors_Item as the provided VMCreateTagResponseErrors1
func (t *VMCreateTagResponse_Errors_Item) FromVMCreateTagResponseErrors1(v VMCreateTagResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMCreateTagResponseErrors1 performs a merge with any union data inside the VMCreateTagResponse_Errors_Item, using the provided VMCreateTagResponseErrors1
func (t *VMCreateTagResponse_Errors_Item) MergeVMCreateTagResponseErrors1(v VMCreateTagResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t VMCreateTagResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VMCreateTagResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVMHibernateResponseErrors0 returns the union data inside the VMHibernateResponse_Errors_Item as a VMHibernateResponseErrors0
func (t VMHibernateResponse_Errors_Item) AsVMHibernateResponseErrors0() (VMHibernateResponseErrors0, error) {
	var body VMHibernateResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMHibernateResponseErrors0 overwrites any union data inside the VMHibernateResponse_Errors_Item as the provided VMHibernateResponseErrors0
func (t *VMHibernateResponse_Errors_Item) FromVMHibernateResponseErrors0(v VMHibernateResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMHibernateResponseErrors0 performs a merge with any union data inside the VMHibernateResponse_Errors_Item, using the provided VMHibernateResponseErrors0
func (t *VMHibernateResponse_Errors_Item) MergeVMHibernateResponseErrors0(v VMHibernateResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVMHibernateResponseErrors1 returns the union data inside the VMHibernateResponse_Errors_Item as a VMHibernateResponseErrors1
func (t VMHibernateResponse_Errors_Item) AsVMHibernateResponseErrors1() (VMHibernateResponseErrors1, error) {
	var body VMHibernateResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMHibernateResponseErrors1 overwrites any union data inside the VMHibernateResponse_Errors_Item as the provided VMHibernateResponseErrors1
func (t *VMHibernateResponse_Errors_Item) FromVMHibernateResponseErrors1(v VMHibernateResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMHibernateResponseErrors1 performs a merge with any union data inside the VMHibernateResponse_Errors_Item, using the provided VMHibernateResponseErrors1
func (t *VMHibernateResponse_Errors_Item) MergeVMHibernateResponseErrors1(v VMHibernateResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t VMHibernateResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VMHibernateResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVMListClustersResponseErrors0 returns the union data inside the VMListClustersResponse_Errors_Item as a VMListClustersResponseErrors0
func (t VMListClustersResponse_Errors_Item) AsVMListClustersResponseErrors0() (VMListClustersResponseErrors0, error) {
	var body VMListClustersResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMListClustersResponseErrors0 overwrites any union data inside the VMListClustersResponse_Errors_Item as the provided VMListClustersResponseErrors0
func (t *VMListClustersResponse_Errors_Item) FromVMListClustersResponseErrors0(v VMListClustersResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMListClustersResponseErrors0 performs a merge with any union data inside the VMListClustersResponse_Errors_Item, using the provided VMListClustersResponseErrors0
func (t *VMListClustersResponse_Errors_Item) MergeVMListClustersResponseErrors0(v VMListClustersResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVMListClustersResponseErrors1 returns the union data inside the VMListClustersResponse_Errors_Item as a VMListClustersResponseErrors1
func (t VMListClustersResponse_Errors_Item) AsVMListClustersResponseErrors1() (VMListClustersResponseErrors1, error) {
	var body VMListClustersResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMListClustersResponseErrors1 overwrites any union data inside the VMListClustersResponse_Errors_Item as the provided VMListClustersResponseErrors1
func (t *VMListClustersResponse_Errors_Item) FromVMListClustersResponseErrors1(v VMListClustersResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMListClustersResponseErrors1 performs a merge with any union data inside the VMListClustersResponse_Errors_Item, using the provided VMListClustersResponseErrors1
func (t *VMListClustersResponse_Errors_Item) MergeVMListClustersResponseErrors1(v VMListClustersResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t VMListClustersResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VMListClustersResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVMListRunningVMsResponseErrors0 returns the union data inside the VMListRunningVMsResponse_Errors_Item as a VMListRunningVMsResponseErrors0
func (t VMListRunningVMsResponse_Errors_Item) AsVMListRunningVMsResponseErrors0() (VMListRunningVMsResponseErrors0, error) {
	var body VMListRunningVMsResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMListRunningVMsResponseErrors0 overwrites any union data inside the VMListRunningVMsResponse_Errors_Item as the provided VMListRunningVMsResponseErrors0
func (t *VMListRunningVMsResponse_Errors_Item) FromVMListRunningVMsResponseErrors0(v VMListRunningVMsResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMListRunningVMsResponseErrors0 performs a merge with any union data inside the VMListRunningVMsResponse_Errors_Item, using the provided VMListRunningVMsResponseErrors0
func (t *VMListRunningVMsResponse_Errors_Item) MergeVMListRunningVMsResponseErrors0(v VMListRunningVMsResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVMListRunningVMsResponseErrors1 returns the union data inside the VMListRunningVMsResponse_Errors_Item as a VMListRunningVMsResponseErrors1
func (t VMListRunningVMsResponse_Errors_Item) AsVMListRunningVMsResponseErrors1() (VMListRunningVMsResponseErrors1, error) {
	var body VMListRunningVMsResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMListRunningVMsResponseErrors1 overwrites any union data inside the VMListRunningVMsResponse_Errors_Item as the provided VMListRunningVMsResponseErrors1
func (t *VMListRunningVMsResponse_Errors_Item) FromVMListRunningVMsResponseErrors1(v VMListRunningVMsResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMListRunningVMsResponseErrors1 performs a merge with any union data inside the VMListRunningVMsResponse_Errors_Item, using the provided VMListRunningVMsResponseErrors1
func (t *VMListRunningVMsResponse_Errors_Item) MergeVMListRunningVMsResponseErrors1(v VMListRunningVMsResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t VMListRunningVMsResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VMListRunningVMsResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVMShutdownResponseErrors0 returns the union data inside the VMShutdownResponse_Errors_Item as a VMShutdownResponseErrors0
func (t VMShutdownResponse_Errors_Item) AsVMShutdownResponseErrors0() (VMShutdownResponseErrors0, error) {
	var body VMShutdownResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMShutdownResponseErrors0 overwrites any union data inside the VMShutdownResponse_Errors_Item as the provided VMShutdownResponseErrors0
func (t *VMShutdownResponse_Errors_Item) FromVMShutdownResponseErrors0(v VMShutdownResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMShutdownResponseErrors0 performs a merge with any union data inside the VMShutdownResponse_Errors_Item, using the provided VMShutdownResponseErrors0
func (t *VMShutdownResponse_Errors_Item) MergeVMShutdownResponseErrors0(v VMShutdownResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVMShutdownResponseErrors1 returns the union data inside the VMShutdownResponse_Errors_Item as a VMShutdownResponseErrors1
func (t VMShutdownResponse_Errors_Item) AsVMShutdownResponseErrors1() (VMShutdownResponseErrors1, error) {
	var body VMShutdownResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMShutdownResponseErrors1 overwrites any union data inside the VMShutdownResponse_Errors_Item as the provided VMShutdownResponseErrors1
func (t *VMShutdownResponse_Errors_Item) FromVMShutdownResponseErrors1(v VMShutdownResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMShutdownResponseErrors1 performs a merge with any union data inside the VMShutdownResponse_Errors_Item, using the provided VMShutdownResponseErrors1
func (t *VMShutdownResponse_Errors_Item) MergeVMShutdownResponseErrors1(v VMShutdownResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t VMShutdownResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VMShutdownResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVMStartResponseErrors0 returns the union data inside the VMStartResponse_Errors_Item as a VMStartResponseErrors0
func (t VMStartResponse_Errors_Item) AsVMStartResponseErrors0() (VMStartResponseErrors0, error) {
	var body VMStartResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMStartResponseErrors0 overwrites any union data inside the VMStartResponse_Errors_Item as the provided VMStartResponseErrors0
func (t *VMStartResponse_Errors_Item) FromVMStartResponseErrors0(v VMStartResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMStartResponseErrors0 performs a merge with any union data inside the VMStartResponse_Errors_Item, using the provided VMStartResponseErrors0
func (t *VMStartResponse_Errors_Item) MergeVMStartResponseErrors0(v VMStartResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVMStartResponseErrors1 returns the union data inside the VMStartResponse_Errors_Item as a VMStartResponseErrors1
func (t VMStartResponse_Errors_Item) AsVMStartResponseErrors1() (VMStartResponseErrors1, error) {
	var body VMStartResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMStartResponseErrors1 overwrites any union data inside the VMStartResponse_Errors_Item as the provided VMStartResponseErrors1
func (t *VMStartResponse_Errors_Item) FromVMStartResponseErrors1(v VMStartResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMStartResponseErrors1 performs a merge with any union data inside the VMStartResponse_Errors_Item, using the provided VMStartResponseErrors1
func (t *VMStartResponse_Errors_Item) MergeVMStartResponseErrors1(v VMStartResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t VMStartResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VMStartResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVMUpdateHibernationTimeoutResponseErrors0 returns the union data inside the VMUpdateHibernationTimeoutResponse_Errors_Item as a VMUpdateHibernationTimeoutResponseErrors0
func (t VMUpdateHibernationTimeoutResponse_Errors_Item) AsVMUpdateHibernationTimeoutResponseErrors0() (VMUpdateHibernationTimeoutResponseErrors0, error) {
	var body VMUpdateHibernationTimeoutResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMUpdateHibernationTimeoutResponseErrors0 overwrites any union data inside the VMUpdateHibernationTimeoutResponse_Errors_Item as the provided VMUpdateHibernationTimeoutResponseErrors0
func (t *VMUpdateHibernationTimeoutResponse_Errors_Item) FromVMUpdateHibernationTimeoutResponseErrors0(v VMUpdateHibernationTimeoutResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMUpdateHibernationTimeoutResponseErrors0 performs a merge with any union data inside the VMUpdateHibernationTimeoutResponse_Errors_Item, using the provided VMUpdateHibernationTimeoutResponseErrors0
func (t *VMUpdateHibernationTimeoutResponse_Errors_Item) MergeVMUpdateHibernationTimeoutResponseErrors0(v VMUpdateHibernationTimeoutResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVMUpdateHibernationTimeoutResponseErrors1 returns the union data inside the VMUpdateHibernationTimeoutResponse_Errors_Item as a VMUpdateHibernationTimeoutResponseErrors1
func (t VMUpdateHibernationTimeoutResponse_Errors_Item) AsVMUpdateHibernationTimeoutResponseErrors1() (VMUpdateHibernationTimeoutResponseErrors1, error) {
	var body VMUpdateHibernationTimeoutResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMUpdateHibernationTimeoutResponseErrors1 overwrites any union data inside the VMUpdateHibernationTimeoutResponse_Errors_Item as the provided VMUpdateHibernationTimeoutResponseErrors1
func (t *VMUpdateHibernationTimeoutResponse_Errors_Item) FromVMUpdateHibernationTimeoutResponseErrors1(v VMUpdateHibernationTimeoutResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMUpdateHibernationTimeoutResponseErrors1 performs a merge with any union data inside the VMUpdateHibernationTimeoutResponse_Errors_Item, using the provided VMUpdateHibernationTimeoutResponseErrors1
func (t *VMUpdateHibernationTimeoutResponse_Errors_Item) MergeVMUpdateHibernationTimeoutResponseErrors1(v VMUpdateHibernationTimeoutResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t VMUpdateHibernationTimeoutResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VMUpdateHibernationTimeoutResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVMUpdateSpecsResponseErrors0 returns the union data inside the VMUpdateSpecsResponse_Errors_Item as a VMUpdateSpecsResponseErrors0
func (t VMUpdateSpecsResponse_Errors_Item) AsVMUpdateSpecsResponseErrors0() (VMUpdateSpecsResponseErrors0, error) {
	var body VMUpdateSpecsResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMUpdateSpecsResponseErrors0 overwrites any union data inside the VMUpdateSpecsResponse_Errors_Item as the provided VMUpdateSpecsResponseErrors0
func (t *VMUpdateSpecsResponse_Errors_Item) FromVMUpdateSpecsResponseErrors0(v VMUpdateSpecsResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMUpdateSpecsResponseErrors0 performs a merge with any union data inside the VMUpdateSpecsResponse_Errors_Item, using the provided VMUpdateSpecsResponseErrors0
func (t *VMUpdateSpecsResponse_Errors_Item) MergeVMUpdateSpecsResponseErrors0(v VMUpdateSpecsResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVMUpdateSpecsResponseErrors1 returns the union data inside the VMUpdateSpecsResponse_Errors_Item as a VMUpdateSpecsResponseErrors1
func (t VMUpdateSpecsResponse_Errors_Item) AsVMUpdateSpecsResponseErrors1() (VMUpdateSpecsResponseErrors1, error) {
	var body VMUpdateSpecsResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMUpdateSpecsResponseErrors1 overwrites any union data inside the VMUpdateSpecsResponse_Errors_Item as the provided VMUpdateSpecsResponseErrors1
func (t *VMUpdateSpecsResponse_Errors_Item) FromVMUpdateSpecsResponseErrors1(v VMUpdateSpecsResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMUpdateSpecsResponseErrors1 performs a merge with any union data inside the VMUpdateSpecsResponse_Errors_Item, using the provided VMUpdateSpecsResponseErrors1
func (t *VMUpdateSpecsResponse_Errors_Item) MergeVMUpdateSpecsResponseErrors1(v VMUpdateSpecsResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t VMUpdateSpecsResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VMUpdateSpecsResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsWorkspaceCreateResponseErrors0 returns the union data inside the WorkspaceCreateResponse_Errors_Item as a WorkspaceCreateResponseErrors0
func (t WorkspaceCreateResponse_Errors_Item) AsWorkspaceCreateResponseErrors0() (WorkspaceCreateResponseErrors0, error) {
	var body WorkspaceCreateResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWorkspaceCreateResponseErrors0 overwrites any union data inside the WorkspaceCreateResponse_Errors_Item as the provided WorkspaceCreateResponseErrors0
func (t *WorkspaceCreateResponse_Errors_Item) FromWorkspaceCreateResponseErrors0(v WorkspaceCreateResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWorkspaceCreateResponseErrors0 performs a merge with any union data inside the WorkspaceCreateResponse_Errors_Item, using the provided WorkspaceCreateResponseErrors0
func (t *WorkspaceCreateResponse_Errors_Item) MergeWorkspaceCreateResponseErrors0(v WorkspaceCreateResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWorkspaceCreateResponseErrors1 returns the union data inside the WorkspaceCreateResponse_Errors_Item as a WorkspaceCreateResponseErrors1
func (t WorkspaceCreateResponse_Errors_Item) AsWorkspaceCreateResponseErrors1() (WorkspaceCreateResponseErrors1, error) {
	var body WorkspaceCreateResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWorkspaceCreateResponseErrors1 overwrites any union data inside the WorkspaceCreateResponse_Errors_Item as the provided WorkspaceCreateResponseErrors1
func (t *WorkspaceCreateResponse_Errors_Item) FromWorkspaceCreateResponseErrors1(v WorkspaceCreateResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWorkspaceCreateResponseErrors1 performs a merge with any union data inside the WorkspaceCreateResponse_Errors_Item, using the provided WorkspaceCreateResponseErrors1
func (t *WorkspaceCreateResponse_Errors_Item) MergeWorkspaceCreateResponseErrors1(v WorkspaceCreateResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t WorkspaceCreateResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *WorkspaceCreateResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// Metainfo request
	Metainfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkspacecreateWithBody request with any body
	WorkspacecreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Workspacecreate(ctx context.Context, body WorkspacecreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TokencreateWithBody request with any body
	TokencreateWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Tokencreate(ctx context.Context, teamId string, body TokencreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TokenupdateWithBody request with any body
	TokenupdateWithBody(ctx context.Context, teamId string, tokenId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Tokenupdate(ctx context.Context, teamId string, tokenId string, body TokenupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Sandboxlist request
	Sandboxlist(ctx context.Context, params *SandboxlistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SandboxcreateWithBody request with any body
	SandboxcreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Sandboxcreate(ctx context.Context, body SandboxcreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Sandboxget request
	Sandboxget(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SandboxforkWithBody request with any body
	SandboxforkWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Sandboxfork(ctx context.Context, id string, body SandboxforkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PreviewTokenrevokeAll request
	PreviewTokenrevokeAll(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PreviewTokenlist request
	PreviewTokenlist(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PreviewTokencreateWithBody request with any body
	PreviewTokencreateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PreviewTokencreate(ctx context.Context, id string, body PreviewTokencreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PreviewTokenupdateWithBody request with any body
	PreviewTokenupdateWithBody(ctx context.Context, id string, tokenId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PreviewTokenupdate(ctx context.Context, id string, tokenId string, body PreviewTokenupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TemplatescreateWithBody request with any body
	TemplatescreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Templatescreate(ctx context.Context, body TemplatescreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VmassignTagAliasWithBody request with any body
	VmassignTagAliasWithBody(ctx context.Context, namespace string, alias string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VmassignTagAlias(ctx context.Context, namespace string, alias string, body VmassignTagAliasJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VmlistClusters request
	VmlistClusters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VmlistRunningVms request
	VmlistRunningVms(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VmcreateTagWithBody request with any body
	VmcreateTagWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VmcreateTag(ctx context.Context, body VmcreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VmhibernateWithBody request with any body
	VmhibernateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Vmhibernate(ctx context.Context, id string, body VmhibernateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VmupdateHibernationTimeoutWithBody request with any body
	VmupdateHibernationTimeoutWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VmupdateHibernationTimeout(ctx context.Context, id string, body VmupdateHibernationTimeoutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VmcreateSessionWithBody request with any body
	VmcreateSessionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VmcreateSession(ctx context.Context, id string, body VmcreateSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VmshutdownWithBody request with any body
	VmshutdownWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Vmshutdown(ctx context.Context, id string, body VmshutdownJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VmupdateSpecsWithBody request with any body
	VmupdateSpecsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VmupdateSpecs(ctx context.Context, id string, body VmupdateSpecsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VmstartWithBody request with any body
	VmstartWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Vmstart(ctx context.Context, id string, body VmstartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VmupdateSpecs2WithBody request with any body
	VmupdateSpecs2WithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VmupdateSpecs2(ctx context.Context, id string, body VmupdateSpecs2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PreviewHostlist request
	PreviewHostlist(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PreviewHostcreateWithBody request with any body
	PreviewHostcreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PreviewHostcreate(ctx context.Context, body PreviewHostcreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PreviewHostupdateWithBody request with any body
	PreviewHostupdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PreviewHostupdate(ctx context.Context, body PreviewHostupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) Metainfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetainfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkspacecreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkspacecreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Workspacecreate(ctx context.Context, body WorkspacecreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkspacecreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TokencreateWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTokencreateRequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Tokencreate(ctx context.Context, teamId string, body TokencreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTokencreateRequest(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TokenupdateWithBody(ctx context.Context, teamId string, tokenId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTokenupdateRequestWithBody(c.Server, teamId, tokenId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Tokenupdate(ctx context.Context, teamId string, tokenId string, body TokenupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTokenupdateRequest(c.Server, teamId, tokenId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Sandboxlist(ctx context.Context, params *SandboxlistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSandboxlistRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SandboxcreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSandboxcreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Sandboxcreate(ctx context.Context, body SandboxcreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSandboxcreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Sandboxget(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSandboxgetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SandboxforkWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSandboxforkRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Sandboxfork(ctx context.Context, id string, body SandboxforkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSandboxforkRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreviewTokenrevokeAll(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreviewTokenrevokeAllRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreviewTokenlist(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreviewTokenlistRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreviewTokencreateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreviewTokencreateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreviewTokencreate(ctx context.Context, id string, body PreviewTokencreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreviewTokencreateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreviewTokenupdateWithBody(ctx context.Context, id string, tokenId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreviewTokenupdateRequestWithBody(c.Server, id, tokenId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreviewTokenupdate(ctx context.Context, id string, tokenId string, body PreviewTokenupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreviewTokenupdateRequest(c.Server, id, tokenId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TemplatescreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTemplatescreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Templatescreate(ctx context.Context, body TemplatescreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTemplatescreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VmassignTagAliasWithBody(ctx context.Context, namespace string, alias string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmassignTagAliasRequestWithBody(c.Server, namespace, alias, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VmassignTagAlias(ctx context.Context, namespace string, alias string, body VmassignTagAliasJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmassignTagAliasRequest(c.Server, namespace, alias, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VmlistClusters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmlistClustersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VmlistRunningVms(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmlistRunningVmsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VmcreateTagWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmcreateTagRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VmcreateTag(ctx context.Context, body VmcreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmcreateTagRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VmhibernateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmhibernateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Vmhibernate(ctx context.Context, id string, body VmhibernateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmhibernateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VmupdateHibernationTimeoutWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmupdateHibernationTimeoutRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VmupdateHibernationTimeout(ctx context.Context, id string, body VmupdateHibernationTimeoutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmupdateHibernationTimeoutRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VmcreateSessionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmcreateSessionRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VmcreateSession(ctx context.Context, id string, body VmcreateSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmcreateSessionRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VmshutdownWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmshutdownRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Vmshutdown(ctx context.Context, id string, body VmshutdownJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmshutdownRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VmupdateSpecsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmupdateSpecsRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VmupdateSpecs(ctx context.Context, id string, body VmupdateSpecsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmupdateSpecsRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VmstartWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmstartRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Vmstart(ctx context.Context, id string, body VmstartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmstartRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VmupdateSpecs2WithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmupdateSpecs2RequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VmupdateSpecs2(ctx context.Context, id string, body VmupdateSpecs2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmupdateSpecs2Request(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreviewHostlist(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreviewHostlistRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreviewHostcreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreviewHostcreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreviewHostcreate(ctx context.Context, body PreviewHostcreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreviewHostcreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreviewHostupdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreviewHostupdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreviewHostupdate(ctx context.Context, body PreviewHostupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreviewHostupdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewMetainfoRequest generates requests for Metainfo
func NewMetainfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meta/info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkspacecreateRequest calls the generic Workspacecreate builder with application/json body
func NewWorkspacecreateRequest(server string, body WorkspacecreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWorkspacecreateRequestWithBody(server, "application/json", bodyReader)
}

// NewWorkspacecreateRequestWithBody generates requests for Workspacecreate with any type of body
func NewWorkspacecreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/workspace")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTokencreateRequest calls the generic Tokencreate builder with application/json body
func NewTokencreateRequest(server string, teamId string, body TokencreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTokencreateRequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewTokencreateRequestWithBody generates requests for Tokencreate with any type of body
func NewTokencreateRequestWithBody(server string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/workspace/%s/tokens", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTokenupdateRequest calls the generic Tokenupdate builder with application/json body
func NewTokenupdateRequest(server string, teamId string, tokenId string, body TokenupdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTokenupdateRequestWithBody(server, teamId, tokenId, "application/json", bodyReader)
}

// NewTokenupdateRequestWithBody generates requests for Tokenupdate with any type of body
func NewTokenupdateRequestWithBody(server string, teamId string, tokenId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "token_id", runtime.ParamLocationPath, tokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/workspace/%s/tokens/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSandboxlistRequest generates requests for Sandboxlist
func NewSandboxlistRequest(server string, params *SandboxlistParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandbox")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSandboxcreateRequest calls the generic Sandboxcreate builder with application/json body
func NewSandboxcreateRequest(server string, body SandboxcreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSandboxcreateRequestWithBody(server, "application/json", bodyReader)
}

// NewSandboxcreateRequestWithBody generates requests for Sandboxcreate with any type of body
func NewSandboxcreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandbox")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSandboxgetRequest generates requests for Sandboxget
func NewSandboxgetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandbox/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSandboxforkRequest calls the generic Sandboxfork builder with application/json body
func NewSandboxforkRequest(server string, id string, body SandboxforkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSandboxforkRequestWithBody(server, id, "application/json", bodyReader)
}

// NewSandboxforkRequestWithBody generates requests for Sandboxfork with any type of body
func NewSandboxforkRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandbox/%s/fork", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPreviewTokenrevokeAllRequest generates requests for PreviewTokenrevokeAll
func NewPreviewTokenrevokeAllRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandbox/%s/tokens", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPreviewTokenlistRequest generates requests for PreviewTokenlist
func NewPreviewTokenlistRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandbox/%s/tokens", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPreviewTokencreateRequest calls the generic PreviewTokencreate builder with application/json body
func NewPreviewTokencreateRequest(server string, id string, body PreviewTokencreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPreviewTokencreateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPreviewTokencreateRequestWithBody generates requests for PreviewTokencreate with any type of body
func NewPreviewTokencreateRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandbox/%s/tokens", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPreviewTokenupdateRequest calls the generic PreviewTokenupdate builder with application/json body
func NewPreviewTokenupdateRequest(server string, id string, tokenId string, body PreviewTokenupdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPreviewTokenupdateRequestWithBody(server, id, tokenId, "application/json", bodyReader)
}

// NewPreviewTokenupdateRequestWithBody generates requests for PreviewTokenupdate with any type of body
func NewPreviewTokenupdateRequestWithBody(server string, id string, tokenId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "token_id", runtime.ParamLocationPath, tokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandbox/%s/tokens/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTemplatescreateRequest calls the generic Templatescreate builder with application/json body
func NewTemplatescreateRequest(server string, body TemplatescreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTemplatescreateRequestWithBody(server, "application/json", bodyReader)
}

// NewTemplatescreateRequestWithBody generates requests for Templatescreate with any type of body
func NewTemplatescreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVmassignTagAliasRequest calls the generic VmassignTagAlias builder with application/json body
func NewVmassignTagAliasRequest(server string, namespace string, alias string, body VmassignTagAliasJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVmassignTagAliasRequestWithBody(server, namespace, alias, "application/json", bodyReader)
}

// NewVmassignTagAliasRequestWithBody generates requests for VmassignTagAlias with any type of body
func NewVmassignTagAliasRequestWithBody(server string, namespace string, alias string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "alias", runtime.ParamLocationPath, alias)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vm/alias/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVmlistClustersRequest generates requests for VmlistClusters
func NewVmlistClustersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vm/clusters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVmlistRunningVmsRequest generates requests for VmlistRunningVms
func NewVmlistRunningVmsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vm/running")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVmcreateTagRequest calls the generic VmcreateTag builder with application/json body
func NewVmcreateTagRequest(server string, body VmcreateTagJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVmcreateTagRequestWithBody(server, "application/json", bodyReader)
}

// NewVmcreateTagRequestWithBody generates requests for VmcreateTag with any type of body
func NewVmcreateTagRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vm/tag")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVmhibernateRequest calls the generic Vmhibernate builder with application/json body
func NewVmhibernateRequest(server string, id string, body VmhibernateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVmhibernateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewVmhibernateRequestWithBody generates requests for Vmhibernate with any type of body
func NewVmhibernateRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vm/%s/hibernate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVmupdateHibernationTimeoutRequest calls the generic VmupdateHibernationTimeout builder with application/json body
func NewVmupdateHibernationTimeoutRequest(server string, id string, body VmupdateHibernationTimeoutJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVmupdateHibernationTimeoutRequestWithBody(server, id, "application/json", bodyReader)
}

// NewVmupdateHibernationTimeoutRequestWithBody generates requests for VmupdateHibernationTimeout with any type of body
func NewVmupdateHibernationTimeoutRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vm/%s/hibernation_timeout", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVmcreateSessionRequest calls the generic VmcreateSession builder with application/json body
func NewVmcreateSessionRequest(server string, id string, body VmcreateSessionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVmcreateSessionRequestWithBody(server, id, "application/json", bodyReader)
}

// NewVmcreateSessionRequestWithBody generates requests for VmcreateSession with any type of body
func NewVmcreateSessionRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vm/%s/sessions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVmshutdownRequest calls the generic Vmshutdown builder with application/json body
func NewVmshutdownRequest(server string, id string, body VmshutdownJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVmshutdownRequestWithBody(server, id, "application/json", bodyReader)
}

// NewVmshutdownRequestWithBody generates requests for Vmshutdown with any type of body
func NewVmshutdownRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vm/%s/shutdown", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVmupdateSpecsRequest calls the generic VmupdateSpecs builder with application/json body
func NewVmupdateSpecsRequest(server string, id string, body VmupdateSpecsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVmupdateSpecsRequestWithBody(server, id, "application/json", bodyReader)
}

// NewVmupdateSpecsRequestWithBody generates requests for VmupdateSpecs with any type of body
func NewVmupdateSpecsRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vm/%s/specs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVmstartRequest calls the generic Vmstart builder with application/json body
func NewVmstartRequest(server string, id string, body VmstartJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVmstartRequestWithBody(server, id, "application/json", bodyReader)
}

// NewVmstartRequestWithBody generates requests for Vmstart with any type of body
func NewVmstartRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vm/%s/start", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVmupdateSpecs2Request calls the generic VmupdateSpecs2 builder with application/json body
func NewVmupdateSpecs2Request(server string, id string, body VmupdateSpecs2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVmupdateSpecs2RequestWithBody(server, id, "application/json", bodyReader)
}

// NewVmupdateSpecs2RequestWithBody generates requests for VmupdateSpecs2 with any type of body
func NewVmupdateSpecs2RequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vm/%s/update_specs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPreviewHostlistRequest generates requests for PreviewHostlist
func NewPreviewHostlistRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspace/preview_hosts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPreviewHostcreateRequest calls the generic PreviewHostcreate builder with application/json body
func NewPreviewHostcreateRequest(server string, body PreviewHostcreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPreviewHostcreateRequestWithBody(server, "application/json", bodyReader)
}

// NewPreviewHostcreateRequestWithBody generates requests for PreviewHostcreate with any type of body
func NewPreviewHostcreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspace/preview_hosts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPreviewHostupdateRequest calls the generic PreviewHostupdate builder with application/json body
func NewPreviewHostupdateRequest(server string, body PreviewHostupdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPreviewHostupdateRequestWithBody(server, "application/json", bodyReader)
}

// NewPreviewHostupdateRequestWithBody generates requests for PreviewHostupdate with any type of body
func NewPreviewHostupdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workspace/preview_hosts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// MetainfoWithResponse request
	MetainfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MetainfoResponse, error)

	// WorkspacecreateWithBodyWithResponse request with any body
	WorkspacecreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorkspacecreateResponse, error)

	WorkspacecreateWithResponse(ctx context.Context, body WorkspacecreateJSONRequestBody, reqEditors ...RequestEditorFn) (*WorkspacecreateResponse, error)

	// TokencreateWithBodyWithResponse request with any body
	TokencreateWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TokencreateResponse, error)

	TokencreateWithResponse(ctx context.Context, teamId string, body TokencreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TokencreateResponse, error)

	// TokenupdateWithBodyWithResponse request with any body
	TokenupdateWithBodyWithResponse(ctx context.Context, teamId string, tokenId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TokenupdateResponse, error)

	TokenupdateWithResponse(ctx context.Context, teamId string, tokenId string, body TokenupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TokenupdateResponse, error)

	// SandboxlistWithResponse request
	SandboxlistWithResponse(ctx context.Context, params *SandboxlistParams, reqEditors ...RequestEditorFn) (*SandboxlistResponse, error)

	// SandboxcreateWithBodyWithResponse request with any body
	SandboxcreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SandboxcreateResponse, error)

	SandboxcreateWithResponse(ctx context.Context, body SandboxcreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SandboxcreateResponse, error)

	// SandboxgetWithResponse request
	SandboxgetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SandboxgetResponse, error)

	// SandboxforkWithBodyWithResponse request with any body
	SandboxforkWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SandboxforkResponse, error)

	SandboxforkWithResponse(ctx context.Context, id string, body SandboxforkJSONRequestBody, reqEditors ...RequestEditorFn) (*SandboxforkResponse, error)

	// PreviewTokenrevokeAllWithResponse request
	PreviewTokenrevokeAllWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PreviewTokenrevokeAllResponse, error)

	// PreviewTokenlistWithResponse request
	PreviewTokenlistWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PreviewTokenlistResponse, error)

	// PreviewTokencreateWithBodyWithResponse request with any body
	PreviewTokencreateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PreviewTokencreateResponse, error)

	PreviewTokencreateWithResponse(ctx context.Context, id string, body PreviewTokencreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PreviewTokencreateResponse, error)

	// PreviewTokenupdateWithBodyWithResponse request with any body
	PreviewTokenupdateWithBodyWithResponse(ctx context.Context, id string, tokenId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PreviewTokenupdateResponse, error)

	PreviewTokenupdateWithResponse(ctx context.Context, id string, tokenId string, body PreviewTokenupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*PreviewTokenupdateResponse, error)

	// TemplatescreateWithBodyWithResponse request with any body
	TemplatescreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TemplatescreateResponse, error)

	TemplatescreateWithResponse(ctx context.Context, body TemplatescreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TemplatescreateResponse, error)

	// VmassignTagAliasWithBodyWithResponse request with any body
	VmassignTagAliasWithBodyWithResponse(ctx context.Context, namespace string, alias string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VmassignTagAliasResponse, error)

	VmassignTagAliasWithResponse(ctx context.Context, namespace string, alias string, body VmassignTagAliasJSONRequestBody, reqEditors ...RequestEditorFn) (*VmassignTagAliasResponse, error)

	// VmlistClustersWithResponse request
	VmlistClustersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*VmlistClustersResponse, error)

	// VmlistRunningVmsWithResponse request
	VmlistRunningVmsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*VmlistRunningVmsResponse, error)

	// VmcreateTagWithBodyWithResponse request with any body
	VmcreateTagWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VmcreateTagResponse, error)

	VmcreateTagWithResponse(ctx context.Context, body VmcreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*VmcreateTagResponse, error)

	// VmhibernateWithBodyWithResponse request with any body
	VmhibernateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VmhibernateResponse, error)

	VmhibernateWithResponse(ctx context.Context, id string, body VmhibernateJSONRequestBody, reqEditors ...RequestEditorFn) (*VmhibernateResponse, error)

	// VmupdateHibernationTimeoutWithBodyWithResponse request with any body
	VmupdateHibernationTimeoutWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VmupdateHibernationTimeoutResponse, error)

	VmupdateHibernationTimeoutWithResponse(ctx context.Context, id string, body VmupdateHibernationTimeoutJSONRequestBody, reqEditors ...RequestEditorFn) (*VmupdateHibernationTimeoutResponse, error)

	// VmcreateSessionWithBodyWithResponse request with any body
	VmcreateSessionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VmcreateSessionResponse, error)

	VmcreateSessionWithResponse(ctx context.Context, id string, body VmcreateSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*VmcreateSessionResponse, error)

	// VmshutdownWithBodyWithResponse request with any body
	VmshutdownWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VmshutdownResponse, error)

	VmshutdownWithResponse(ctx context.Context, id string, body VmshutdownJSONRequestBody, reqEditors ...RequestEditorFn) (*VmshutdownResponse, error)

	// VmupdateSpecsWithBodyWithResponse request with any body
	VmupdateSpecsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VmupdateSpecsResponse, error)

	VmupdateSpecsWithResponse(ctx context.Context, id string, body VmupdateSpecsJSONRequestBody, reqEditors ...RequestEditorFn) (*VmupdateSpecsResponse, error)

	// VmstartWithBodyWithResponse request with any body
	VmstartWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VmstartResponse, error)

	VmstartWithResponse(ctx context.Context, id string, body VmstartJSONRequestBody, reqEditors ...RequestEditorFn) (*VmstartResponse, error)

	// VmupdateSpecs2WithBodyWithResponse request with any body
	VmupdateSpecs2WithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VmupdateSpecs2Response, error)

	VmupdateSpecs2WithResponse(ctx context.Context, id string, body VmupdateSpecs2JSONRequestBody, reqEditors ...RequestEditorFn) (*VmupdateSpecs2Response, error)

	// PreviewHostlistWithResponse request
	PreviewHostlistWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PreviewHostlistResponse, error)

	// PreviewHostcreateWithBodyWithResponse request with any body
	PreviewHostcreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PreviewHostcreateResponse, error)

	PreviewHostcreateWithResponse(ctx context.Context, body PreviewHostcreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PreviewHostcreateResponse, error)

	// PreviewHostupdateWithBodyWithResponse request with any body
	PreviewHostupdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PreviewHostupdateResponse, error)

	PreviewHostupdateWithResponse(ctx context.Context, body PreviewHostupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*PreviewHostupdateResponse, error)
}

type MetainfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetaInformation
}

// Status returns HTTPResponse.Status
func (r MetainfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetainfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkspacecreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *WorkspaceCreateResponse
}

// Status returns HTTPResponse.Status
func (r WorkspacecreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkspacecreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TokencreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TokenCreateResponse
}

// Status returns HTTPResponse.Status
func (r TokencreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TokencreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TokenupdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TokenUpdateResponse
}

// Status returns HTTPResponse.Status
func (r TokenupdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TokenupdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SandboxlistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SandboxListResponse
}

// Status returns HTTPResponse.Status
func (r SandboxlistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SandboxlistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SandboxcreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SandboxCreateResponse
}

// Status returns HTTPResponse.Status
func (r SandboxcreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SandboxcreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SandboxgetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SandboxGetResponse
}

// Status returns HTTPResponse.Status
func (r SandboxgetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SandboxgetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SandboxforkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SandboxForkResponse
}

// Status returns HTTPResponse.Status
func (r SandboxforkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SandboxforkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PreviewTokenrevokeAllResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PreviewTokenRevokeAllResponse
}

// Status returns HTTPResponse.Status
func (r PreviewTokenrevokeAllResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PreviewTokenrevokeAllResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PreviewTokenlistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PreviewTokenListResponse
}

// Status returns HTTPResponse.Status
func (r PreviewTokenlistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PreviewTokenlistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PreviewTokencreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PreviewTokenCreateResponse
}

// Status returns HTTPResponse.Status
func (r PreviewTokencreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PreviewTokencreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PreviewTokenupdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PreviewTokenUpdateResponse
}

// Status returns HTTPResponse.Status
func (r PreviewTokenupdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PreviewTokenupdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TemplatescreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TemplateCreateResponse
}

// Status returns HTTPResponse.Status
func (r TemplatescreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TemplatescreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VmassignTagAliasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VMAssignTagAliasResponse
}

// Status returns HTTPResponse.Status
func (r VmassignTagAliasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VmassignTagAliasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VmlistClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VMListClustersResponse
}

// Status returns HTTPResponse.Status
func (r VmlistClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VmlistClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VmlistRunningVmsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VMListRunningVMsResponse
}

// Status returns HTTPResponse.Status
func (r VmlistRunningVmsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VmlistRunningVmsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VmcreateTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VMCreateTagResponse
}

// Status returns HTTPResponse.Status
func (r VmcreateTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VmcreateTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VmhibernateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VMHibernateResponse
}

// Status returns HTTPResponse.Status
func (r VmhibernateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VmhibernateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VmupdateHibernationTimeoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VMUpdateHibernationTimeoutResponse
}

// Status returns HTTPResponse.Status
func (r VmupdateHibernationTimeoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VmupdateHibernationTimeoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VmcreateSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VMCreateSessionResponse
}

// Status returns HTTPResponse.Status
func (r VmcreateSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VmcreateSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VmshutdownResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VMShutdownResponse
}

// Status returns HTTPResponse.Status
func (r VmshutdownResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VmshutdownResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VmupdateSpecsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VMUpdateSpecsResponse
}

// Status returns HTTPResponse.Status
func (r VmupdateSpecsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VmupdateSpecsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VmstartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VMStartResponse
}

// Status returns HTTPResponse.Status
func (r VmstartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VmstartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VmupdateSpecs2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VMUpdateSpecsResponse
}

// Status returns HTTPResponse.Status
func (r VmupdateSpecs2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VmupdateSpecs2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PreviewHostlistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PreviewHostListResponse
}

// Status returns HTTPResponse.Status
func (r PreviewHostlistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PreviewHostlistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PreviewHostcreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PreviewHostListResponse
}

// Status returns HTTPResponse.Status
func (r PreviewHostcreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PreviewHostcreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PreviewHostupdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PreviewHostListResponse
}

// Status returns HTTPResponse.Status
func (r PreviewHostupdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PreviewHostupdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// MetainfoWithResponse request returning *MetainfoResponse
func (c *ClientWithResponses) MetainfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MetainfoResponse, error) {
	rsp, err := c.Metainfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetainfoResponse(rsp)
}

// WorkspacecreateWithBodyWithResponse request with arbitrary body returning *WorkspacecreateResponse
func (c *ClientWithResponses) WorkspacecreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorkspacecreateResponse, error) {
	rsp, err := c.WorkspacecreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkspacecreateResponse(rsp)
}

func (c *ClientWithResponses) WorkspacecreateWithResponse(ctx context.Context, body WorkspacecreateJSONRequestBody, reqEditors ...RequestEditorFn) (*WorkspacecreateResponse, error) {
	rsp, err := c.Workspacecreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkspacecreateResponse(rsp)
}

// TokencreateWithBodyWithResponse request with arbitrary body returning *TokencreateResponse
func (c *ClientWithResponses) TokencreateWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TokencreateResponse, error) {
	rsp, err := c.TokencreateWithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTokencreateResponse(rsp)
}

func (c *ClientWithResponses) TokencreateWithResponse(ctx context.Context, teamId string, body TokencreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TokencreateResponse, error) {
	rsp, err := c.Tokencreate(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTokencreateResponse(rsp)
}

// TokenupdateWithBodyWithResponse request with arbitrary body returning *TokenupdateResponse
func (c *ClientWithResponses) TokenupdateWithBodyWithResponse(ctx context.Context, teamId string, tokenId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TokenupdateResponse, error) {
	rsp, err := c.TokenupdateWithBody(ctx, teamId, tokenId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTokenupdateResponse(rsp)
}

func (c *ClientWithResponses) TokenupdateWithResponse(ctx context.Context, teamId string, tokenId string, body TokenupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TokenupdateResponse, error) {
	rsp, err := c.Tokenupdate(ctx, teamId, tokenId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTokenupdateResponse(rsp)
}

// SandboxlistWithResponse request returning *SandboxlistResponse
func (c *ClientWithResponses) SandboxlistWithResponse(ctx context.Context, params *SandboxlistParams, reqEditors ...RequestEditorFn) (*SandboxlistResponse, error) {
	rsp, err := c.Sandboxlist(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSandboxlistResponse(rsp)
}

// SandboxcreateWithBodyWithResponse request with arbitrary body returning *SandboxcreateResponse
func (c *ClientWithResponses) SandboxcreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SandboxcreateResponse, error) {
	rsp, err := c.SandboxcreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSandboxcreateResponse(rsp)
}

func (c *ClientWithResponses) SandboxcreateWithResponse(ctx context.Context, body SandboxcreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SandboxcreateResponse, error) {
	rsp, err := c.Sandboxcreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSandboxcreateResponse(rsp)
}

// SandboxgetWithResponse request returning *SandboxgetResponse
func (c *ClientWithResponses) SandboxgetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SandboxgetResponse, error) {
	rsp, err := c.Sandboxget(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSandboxgetResponse(rsp)
}

// SandboxforkWithBodyWithResponse request with arbitrary body returning *SandboxforkResponse
func (c *ClientWithResponses) SandboxforkWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SandboxforkResponse, error) {
	rsp, err := c.SandboxforkWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSandboxforkResponse(rsp)
}

func (c *ClientWithResponses) SandboxforkWithResponse(ctx context.Context, id string, body SandboxforkJSONRequestBody, reqEditors ...RequestEditorFn) (*SandboxforkResponse, error) {
	rsp, err := c.Sandboxfork(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSandboxforkResponse(rsp)
}

// PreviewTokenrevokeAllWithResponse request returning *PreviewTokenrevokeAllResponse
func (c *ClientWithResponses) PreviewTokenrevokeAllWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PreviewTokenrevokeAllResponse, error) {
	rsp, err := c.PreviewTokenrevokeAll(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreviewTokenrevokeAllResponse(rsp)
}

// PreviewTokenlistWithResponse request returning *PreviewTokenlistResponse
func (c *ClientWithResponses) PreviewTokenlistWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*PreviewTokenlistResponse, error) {
	rsp, err := c.PreviewTokenlist(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreviewTokenlistResponse(rsp)
}

// PreviewTokencreateWithBodyWithResponse request with arbitrary body returning *PreviewTokencreateResponse
func (c *ClientWithResponses) PreviewTokencreateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PreviewTokencreateResponse, error) {
	rsp, err := c.PreviewTokencreateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreviewTokencreateResponse(rsp)
}

func (c *ClientWithResponses) PreviewTokencreateWithResponse(ctx context.Context, id string, body PreviewTokencreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PreviewTokencreateResponse, error) {
	rsp, err := c.PreviewTokencreate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreviewTokencreateResponse(rsp)
}

// PreviewTokenupdateWithBodyWithResponse request with arbitrary body returning *PreviewTokenupdateResponse
func (c *ClientWithResponses) PreviewTokenupdateWithBodyWithResponse(ctx context.Context, id string, tokenId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PreviewTokenupdateResponse, error) {
	rsp, err := c.PreviewTokenupdateWithBody(ctx, id, tokenId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreviewTokenupdateResponse(rsp)
}

func (c *ClientWithResponses) PreviewTokenupdateWithResponse(ctx context.Context, id string, tokenId string, body PreviewTokenupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*PreviewTokenupdateResponse, error) {
	rsp, err := c.PreviewTokenupdate(ctx, id, tokenId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreviewTokenupdateResponse(rsp)
}

// TemplatescreateWithBodyWithResponse request with arbitrary body returning *TemplatescreateResponse
func (c *ClientWithResponses) TemplatescreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TemplatescreateResponse, error) {
	rsp, err := c.TemplatescreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTemplatescreateResponse(rsp)
}

func (c *ClientWithResponses) TemplatescreateWithResponse(ctx context.Context, body TemplatescreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TemplatescreateResponse, error) {
	rsp, err := c.Templatescreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTemplatescreateResponse(rsp)
}

// VmassignTagAliasWithBodyWithResponse request with arbitrary body returning *VmassignTagAliasResponse
func (c *ClientWithResponses) VmassignTagAliasWithBodyWithResponse(ctx context.Context, namespace string, alias string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VmassignTagAliasResponse, error) {
	rsp, err := c.VmassignTagAliasWithBody(ctx, namespace, alias, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmassignTagAliasResponse(rsp)
}

func (c *ClientWithResponses) VmassignTagAliasWithResponse(ctx context.Context, namespace string, alias string, body VmassignTagAliasJSONRequestBody, reqEditors ...RequestEditorFn) (*VmassignTagAliasResponse, error) {
	rsp, err := c.VmassignTagAlias(ctx, namespace, alias, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmassignTagAliasResponse(rsp)
}

// VmlistClustersWithResponse request returning *VmlistClustersResponse
func (c *ClientWithResponses) VmlistClustersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*VmlistClustersResponse, error) {
	rsp, err := c.VmlistClusters(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmlistClustersResponse(rsp)
}

// VmlistRunningVmsWithResponse request returning *VmlistRunningVmsResponse
func (c *ClientWithResponses) VmlistRunningVmsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*VmlistRunningVmsResponse, error) {
	rsp, err := c.VmlistRunningVms(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmlistRunningVmsResponse(rsp)
}

// VmcreateTagWithBodyWithResponse request with arbitrary body returning *VmcreateTagResponse
func (c *ClientWithResponses) VmcreateTagWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VmcreateTagResponse, error) {
	rsp, err := c.VmcreateTagWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmcreateTagResponse(rsp)
}

func (c *ClientWithResponses) VmcreateTagWithResponse(ctx context.Context, body VmcreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*VmcreateTagResponse, error) {
	rsp, err := c.VmcreateTag(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmcreateTagResponse(rsp)
}

// VmhibernateWithBodyWithResponse request with arbitrary body returning *VmhibernateResponse
func (c *ClientWithResponses) VmhibernateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VmhibernateResponse, error) {
	rsp, err := c.VmhibernateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmhibernateResponse(rsp)
}

func (c *ClientWithResponses) VmhibernateWithResponse(ctx context.Context, id string, body VmhibernateJSONRequestBody, reqEditors ...RequestEditorFn) (*VmhibernateResponse, error) {
	rsp, err := c.Vmhibernate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmhibernateResponse(rsp)
}

// VmupdateHibernationTimeoutWithBodyWithResponse request with arbitrary body returning *VmupdateHibernationTimeoutResponse
func (c *ClientWithResponses) VmupdateHibernationTimeoutWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VmupdateHibernationTimeoutResponse, error) {
	rsp, err := c.VmupdateHibernationTimeoutWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmupdateHibernationTimeoutResponse(rsp)
}

func (c *ClientWithResponses) VmupdateHibernationTimeoutWithResponse(ctx context.Context, id string, body VmupdateHibernationTimeoutJSONRequestBody, reqEditors ...RequestEditorFn) (*VmupdateHibernationTimeoutResponse, error) {
	rsp, err := c.VmupdateHibernationTimeout(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmupdateHibernationTimeoutResponse(rsp)
}

// VmcreateSessionWithBodyWithResponse request with arbitrary body returning *VmcreateSessionResponse
func (c *ClientWithResponses) VmcreateSessionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VmcreateSessionResponse, error) {
	rsp, err := c.VmcreateSessionWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmcreateSessionResponse(rsp)
}

func (c *ClientWithResponses) VmcreateSessionWithResponse(ctx context.Context, id string, body VmcreateSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*VmcreateSessionResponse, error) {
	rsp, err := c.VmcreateSession(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmcreateSessionResponse(rsp)
}

// VmshutdownWithBodyWithResponse request with arbitrary body returning *VmshutdownResponse
func (c *ClientWithResponses) VmshutdownWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VmshutdownResponse, error) {
	rsp, err := c.VmshutdownWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmshutdownResponse(rsp)
}

func (c *ClientWithResponses) VmshutdownWithResponse(ctx context.Context, id string, body VmshutdownJSONRequestBody, reqEditors ...RequestEditorFn) (*VmshutdownResponse, error) {
	rsp, err := c.Vmshutdown(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmshutdownResponse(rsp)
}

// VmupdateSpecsWithBodyWithResponse request with arbitrary body returning *VmupdateSpecsResponse
func (c *ClientWithResponses) VmupdateSpecsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VmupdateSpecsResponse, error) {
	rsp, err := c.VmupdateSpecsWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmupdateSpecsResponse(rsp)
}

func (c *ClientWithResponses) VmupdateSpecsWithResponse(ctx context.Context, id string, body VmupdateSpecsJSONRequestBody, reqEditors ...RequestEditorFn) (*VmupdateSpecsResponse, error) {
	rsp, err := c.VmupdateSpecs(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmupdateSpecsResponse(rsp)
}

// VmstartWithBodyWithResponse request with arbitrary body returning *VmstartResponse
func (c *ClientWithResponses) VmstartWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VmstartResponse, error) {
	rsp, err := c.VmstartWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmstartResponse(rsp)
}

func (c *ClientWithResponses) VmstartWithResponse(ctx context.Context, id string, body VmstartJSONRequestBody, reqEditors ...RequestEditorFn) (*VmstartResponse, error) {
	rsp, err := c.Vmstart(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmstartResponse(rsp)
}

// VmupdateSpecs2WithBodyWithResponse request with arbitrary body returning *VmupdateSpecs2Response
func (c *ClientWithResponses) VmupdateSpecs2WithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VmupdateSpecs2Response, error) {
	rsp, err := c.VmupdateSpecs2WithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmupdateSpecs2Response(rsp)
}

func (c *ClientWithResponses) VmupdateSpecs2WithResponse(ctx context.Context, id string, body VmupdateSpecs2JSONRequestBody, reqEditors ...RequestEditorFn) (*VmupdateSpecs2Response, error) {
	rsp, err := c.VmupdateSpecs2(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmupdateSpecs2Response(rsp)
}

// PreviewHostlistWithResponse request returning *PreviewHostlistResponse
func (c *ClientWithResponses) PreviewHostlistWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PreviewHostlistResponse, error) {
	rsp, err := c.PreviewHostlist(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreviewHostlistResponse(rsp)
}

// PreviewHostcreateWithBodyWithResponse request with arbitrary body returning *PreviewHostcreateResponse
func (c *ClientWithResponses) PreviewHostcreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PreviewHostcreateResponse, error) {
	rsp, err := c.PreviewHostcreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreviewHostcreateResponse(rsp)
}

func (c *ClientWithResponses) PreviewHostcreateWithResponse(ctx context.Context, body PreviewHostcreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PreviewHostcreateResponse, error) {
	rsp, err := c.PreviewHostcreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreviewHostcreateResponse(rsp)
}

// PreviewHostupdateWithBodyWithResponse request with arbitrary body returning *PreviewHostupdateResponse
func (c *ClientWithResponses) PreviewHostupdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PreviewHostupdateResponse, error) {
	rsp, err := c.PreviewHostupdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreviewHostupdateResponse(rsp)
}

func (c *ClientWithResponses) PreviewHostupdateWithResponse(ctx context.Context, body PreviewHostupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*PreviewHostupdateResponse, error) {
	rsp, err := c.PreviewHostupdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreviewHostupdateResponse(rsp)
}

// ParseMetainfoResponse parses an HTTP response from a MetainfoWithResponse call
func ParseMetainfoResponse(rsp *http.Response) (*MetainfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetainfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetaInformation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWorkspacecreateResponse parses an HTTP response from a WorkspacecreateWithResponse call
func ParseWorkspacecreateResponse(rsp *http.Response) (*WorkspacecreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkspacecreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest WorkspaceCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseTokencreateResponse parses an HTTP response from a TokencreateWithResponse call
func ParseTokencreateResponse(rsp *http.Response) (*TokencreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TokencreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TokenCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseTokenupdateResponse parses an HTTP response from a TokenupdateWithResponse call
func ParseTokenupdateResponse(rsp *http.Response) (*TokenupdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TokenupdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TokenUpdateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseSandboxlistResponse parses an HTTP response from a SandboxlistWithResponse call
func ParseSandboxlistResponse(rsp *http.Response) (*SandboxlistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SandboxlistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SandboxListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSandboxcreateResponse parses an HTTP response from a SandboxcreateWithResponse call
func ParseSandboxcreateResponse(rsp *http.Response) (*SandboxcreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SandboxcreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SandboxCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseSandboxgetResponse parses an HTTP response from a SandboxgetWithResponse call
func ParseSandboxgetResponse(rsp *http.Response) (*SandboxgetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SandboxgetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SandboxGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSandboxforkResponse parses an HTTP response from a SandboxforkWithResponse call
func ParseSandboxforkResponse(rsp *http.Response) (*SandboxforkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SandboxforkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SandboxForkResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParsePreviewTokenrevokeAllResponse parses an HTTP response from a PreviewTokenrevokeAllWithResponse call
func ParsePreviewTokenrevokeAllResponse(rsp *http.Response) (*PreviewTokenrevokeAllResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PreviewTokenrevokeAllResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PreviewTokenRevokeAllResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePreviewTokenlistResponse parses an HTTP response from a PreviewTokenlistWithResponse call
func ParsePreviewTokenlistResponse(rsp *http.Response) (*PreviewTokenlistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PreviewTokenlistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PreviewTokenListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParsePreviewTokencreateResponse parses an HTTP response from a PreviewTokencreateWithResponse call
func ParsePreviewTokencreateResponse(rsp *http.Response) (*PreviewTokencreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PreviewTokencreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PreviewTokenCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParsePreviewTokenupdateResponse parses an HTTP response from a PreviewTokenupdateWithResponse call
func ParsePreviewTokenupdateResponse(rsp *http.Response) (*PreviewTokenupdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PreviewTokenupdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PreviewTokenUpdateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseTemplatescreateResponse parses an HTTP response from a TemplatescreateWithResponse call
func ParseTemplatescreateResponse(rsp *http.Response) (*TemplatescreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TemplatescreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TemplateCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseVmassignTagAliasResponse parses an HTTP response from a VmassignTagAliasWithResponse call
func ParseVmassignTagAliasResponse(rsp *http.Response) (*VmassignTagAliasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VmassignTagAliasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VMAssignTagAliasResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVmlistClustersResponse parses an HTTP response from a VmlistClustersWithResponse call
func ParseVmlistClustersResponse(rsp *http.Response) (*VmlistClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VmlistClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VMListClustersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVmlistRunningVmsResponse parses an HTTP response from a VmlistRunningVmsWithResponse call
func ParseVmlistRunningVmsResponse(rsp *http.Response) (*VmlistRunningVmsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VmlistRunningVmsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VMListRunningVMsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVmcreateTagResponse parses an HTTP response from a VmcreateTagWithResponse call
func ParseVmcreateTagResponse(rsp *http.Response) (*VmcreateTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VmcreateTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VMCreateTagResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVmhibernateResponse parses an HTTP response from a VmhibernateWithResponse call
func ParseVmhibernateResponse(rsp *http.Response) (*VmhibernateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VmhibernateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VMHibernateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVmupdateHibernationTimeoutResponse parses an HTTP response from a VmupdateHibernationTimeoutWithResponse call
func ParseVmupdateHibernationTimeoutResponse(rsp *http.Response) (*VmupdateHibernationTimeoutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VmupdateHibernationTimeoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VMUpdateHibernationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVmcreateSessionResponse parses an HTTP response from a VmcreateSessionWithResponse call
func ParseVmcreateSessionResponse(rsp *http.Response) (*VmcreateSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VmcreateSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VMCreateSessionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVmshutdownResponse parses an HTTP response from a VmshutdownWithResponse call
func ParseVmshutdownResponse(rsp *http.Response) (*VmshutdownResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VmshutdownResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VMShutdownResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVmupdateSpecsResponse parses an HTTP response from a VmupdateSpecsWithResponse call
func ParseVmupdateSpecsResponse(rsp *http.Response) (*VmupdateSpecsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VmupdateSpecsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VMUpdateSpecsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVmstartResponse parses an HTTP response from a VmstartWithResponse call
func ParseVmstartResponse(rsp *http.Response) (*VmstartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VmstartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VMStartResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVmupdateSpecs2Response parses an HTTP response from a VmupdateSpecs2WithResponse call
func ParseVmupdateSpecs2Response(rsp *http.Response) (*VmupdateSpecs2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VmupdateSpecs2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VMUpdateSpecsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePreviewHostlistResponse parses an HTTP response from a PreviewHostlistWithResponse call
func ParsePreviewHostlistResponse(rsp *http.Response) (*PreviewHostlistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PreviewHostlistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PreviewHostListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParsePreviewHostcreateResponse parses an HTTP response from a PreviewHostcreateWithResponse call
func ParsePreviewHostcreateResponse(rsp *http.Response) (*PreviewHostcreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PreviewHostcreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PreviewHostListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParsePreviewHostupdateResponse parses an HTTP response from a PreviewHostupdateWithResponse call
func ParsePreviewHostupdateResponse(rsp *http.Response) (*PreviewHostupdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PreviewHostupdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PreviewHostListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}
