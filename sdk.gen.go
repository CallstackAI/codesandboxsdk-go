// Package codesandboxsdk provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.2.0 DO NOT EDIT.
package codesandboxsdk

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	AuthorizationScopes = "authorization.Scopes"
)

// Defines values for SandboxCreateRequestRuntime.
const (
	Browser SandboxCreateRequestRuntime = "browser"
	Vm      SandboxCreateRequestRuntime = "vm"
)

// Defines values for VMCreateSessionRequestPermission.
const (
	Read  VMCreateSessionRequestPermission = "read"
	Write VMCreateSessionRequestPermission = "write"
)

// MetaInformation defines model for MetaInformation.
type MetaInformation struct {
	// Api Meta information about the CodeSandbox API
	Api struct {
		LatestVersion string `json:"latest_version"`
		Name          string `json:"name"`
	} `json:"api"`

	// Auth Meta information about the current authentication context
	Auth *struct {
		Scopes  []string            `json:"scopes"`
		Team    *openapi_types.UUID `json:"team"`
		Version string              `json:"version"`
	} `json:"auth,omitempty"`
}

// Sandbox defines model for Sandbox.
type Sandbox struct {
	Alias       *string  `json:"alias,omitempty"`
	CreatedAt   Time     `json:"created_at"`
	Description *string  `json:"description"`
	Id          string   `json:"id"`
	IsFrozen    bool     `json:"is_frozen"`
	Privacy     int      `json:"privacy"`
	Tags        []string `json:"tags"`
	Title       *string  `json:"title"`
	UpdatedAt   Time     `json:"updated_at"`
}

// SandboxCreateRequest defines model for SandboxCreateRequest.
type SandboxCreateRequest struct {
	// Description Optional text description of the sandbox. Defaults to no description.
	Description *string `json:"description,omitempty"`

	// Entry Filename of the entrypoint of the sandbox.
	Entry *string `json:"entry,omitempty"`

	// ExternalResources Array of strings with external resources to load.
	ExternalResources *[]string `json:"external_resources,omitempty"`

	// Files Map of `path => file` where each file is a map.
	Files map[string]struct {
		// BinaryContent If the file has binary (non plain-text) contents, place the base-64 encoded contents in this key. Should be empty or missing if `is_binary` is `false`.
		BinaryContent *string `json:"binary_content,omitempty"`

		// Code If the file is non-binary in nature, place the (escaped) plain text contents in this key. Should be empty or missing if `is_binary` is `true`.
		Code *string `json:"code,omitempty"`

		// IsBinary Whether the file contains binary contents.
		IsBinary *bool `json:"is_binary,omitempty"`
	} `json:"files"`

	// IsFrozen Whether changes to the sandbox are disallowed. Defaults to `false`.
	IsFrozen *bool `json:"is_frozen,omitempty"`

	// NpmDependencies Map of dependencies and their version specifications.
	NpmDependencies *map[string]string `json:"npm_dependencies,omitempty"`

	// Path Path to the collection where the new sandbox should be stored. Defaults to "/". If no collection exists at the given path, it will be created.
	Path *string `json:"path,omitempty"`

	// Privacy 0 for public, 1 for unlisted, and 2 for private. Privacy is subject to certain restrictions (team minimum setting, drafts must be private, etc.). Defaults to public.
	Privacy *int `json:"privacy,omitempty"`

	// Runtime Runtime to use for the sandbox. Defaults to `"browser"`.
	Runtime *SandboxCreateRequestRuntime `json:"runtime,omitempty"`

	// Tags List of string tags to apply to the sandbox. Only the first ten will be used. Defaults to no tags.
	Tags *[]string `json:"tags,omitempty"`

	// Template Name of the template from which the sandbox is derived (for example, `"static"`).
	Template *string `json:"template,omitempty"`

	// Title Sandbox title. Maximum 255 characters. Defaults to no title.
	Title *string `json:"title,omitempty"`
}

// SandboxCreateRequestRuntime Runtime to use for the sandbox. Defaults to `"browser"`.
type SandboxCreateRequestRuntime string

// SandboxCreateResponse defines model for SandboxCreateResponse.
type SandboxCreateResponse struct {
	Data *struct {
		Alias string  `json:"alias"`
		Id    string  `json:"id"`
		Title *string `json:"title"`
	} `json:"data,omitempty"`
	Errors  *[]SandboxCreateResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                                `json:"success,omitempty"`
}

// SandboxCreateResponseErrors0 defines model for .
type SandboxCreateResponseErrors0 = string

// SandboxCreateResponseErrors1 defines model for .
type SandboxCreateResponseErrors1 map[string]interface{}

// SandboxCreateResponse_Errors_Item defines model for SandboxCreateResponse.errors.Item.
type SandboxCreateResponse_Errors_Item struct {
	union json.RawMessage
}

// SandboxForkRequest defines model for SandboxForkRequest.
type SandboxForkRequest struct {
	// Description Sandbox description. Maximum 255 characters. Defaults to description of original sandbox.
	Description *string `json:"description,omitempty"`

	// IsFrozen Sandbox frozen status. When true, edits to the sandbox are restricted. Defaults to frozen status of the original sandbox.
	IsFrozen *bool `json:"is_frozen,omitempty"`

	// Path Path to the collection where the new sandbox should be stored. Defaults to "/". If no collection exists at the given path, it will be created.
	Path *string `json:"path,omitempty"`

	// Privacy Sandbox privacy. 0 for public, 1 for unlisted, and 2 for private. Subject to the minimum privacy restrictions of the workspace. Defaults to the privacy of the original sandbox.
	Privacy *int `json:"privacy,omitempty"`

	// StartOptions Optional VM start configuration. If provided, the sandbox VM will be started immediately after creation.
	StartOptions *struct {
		// HibernationTimeoutSeconds The time in seconds after which the VM will hibernate due to inactivity.
		// Must be a positive integer between 1 and 86400 (24 hours).
		// Defaults to 300 seconds (5 minutes) if not specified.
		HibernationTimeoutSeconds *int `json:"hibernation_timeout_seconds,omitempty"`

		// Ipcountry This determines in which cluster, closest to the given country the VM will be started in. The format is ISO-3166-1 alpha-2. If not set, the VM will be started closest to the caller of this API. This will only be applied when a VM is run for the first time, and will only serve as a hint (e.g. if the template of this sandbox runs in EU cluster, this sandbox will also run in the EU cluster).
		Ipcountry *string `json:"ipcountry,omitempty"`

		// Tier Determines which specs to start the VM with. If not specified, the VM will start with the default specs for the workspace.
		//
		// You can only specify a VM tier when starting a VM that is inside your workspace. Specifying a VM tier for someone else's sandbox will return an error.
		//
		// Not all tiers will be available depending on the workspace subscription status, and higher tiers incur higher costs. Please see codesandbox.io/pricing for details on specs and costs.
		Tier *interface{} `json:"tier,omitempty"`
	} `json:"start_options,omitempty"`

	// Tags Tags to set on the new sandbox, if any. Will not inherit tags from the source sandbox.
	Tags *[]string `json:"tags,omitempty"`

	// Title Sandbox title. Maximum 255 characters. Defaults to title of original sandbox with (forked).
	Title *string `json:"title,omitempty"`
}

// SandboxForkResponse defines model for SandboxForkResponse.
type SandboxForkResponse struct {
	Data *struct {
		Alias         string       `json:"alias"`
		Id            string       `json:"id"`
		StartResponse *VMStartData `json:"start_response,omitempty"`
		Title         *string      `json:"title"`
	} `json:"data,omitempty"`
	Errors  *[]SandboxForkResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                              `json:"success,omitempty"`
}

// SandboxForkResponseErrors0 defines model for .
type SandboxForkResponseErrors0 = string

// SandboxForkResponseErrors1 defines model for .
type SandboxForkResponseErrors1 map[string]interface{}

// SandboxForkResponse_Errors_Item defines model for SandboxForkResponse.errors.Item.
type SandboxForkResponse_Errors_Item struct {
	union json.RawMessage
}

// SandboxGetResponse defines model for SandboxGetResponse.
type SandboxGetResponse struct {
	Data    *Sandbox                          `json:"data,omitempty"`
	Errors  *[]SandboxGetResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                             `json:"success,omitempty"`
}

// SandboxGetResponseErrors0 defines model for .
type SandboxGetResponseErrors0 = string

// SandboxGetResponseErrors1 defines model for .
type SandboxGetResponseErrors1 map[string]interface{}

// SandboxGetResponse_Errors_Item defines model for SandboxGetResponse.errors.Item.
type SandboxGetResponse_Errors_Item struct {
	union json.RawMessage
}

// SandboxListResponse defines model for SandboxListResponse.
type SandboxListResponse struct {
	Data *struct {
		Pagination struct {
			CurrentPage int `json:"current_page"`

			// NextPage The number of the next page, if any. If `null`, the current page is the last page of records.
			NextPage     *int `json:"next_page"`
			TotalRecords int  `json:"total_records"`
		} `json:"pagination"`
		Sandboxes []Sandbox `json:"sandboxes"`
	} `json:"data,omitempty"`
	Errors  *[]SandboxListResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                              `json:"success,omitempty"`
}

// SandboxListResponseErrors0 defines model for .
type SandboxListResponseErrors0 = string

// SandboxListResponseErrors1 defines model for .
type SandboxListResponseErrors1 map[string]interface{}

// SandboxListResponse_Errors_Item defines model for SandboxListResponse.errors.Item.
type SandboxListResponse_Errors_Item struct {
	union json.RawMessage
}

// TokenCreateRequest defines model for TokenCreateRequest.
type TokenCreateRequest struct {
	// DefaultVersion API Version to use, formatted as YYYY-MM-DD. Defaults to the latest version at time of creation.
	DefaultVersion *openapi_types.Date `json:"default_version"`

	// Description Description of this token, for instance where it will be used.
	Description *string `json:"description,omitempty"`

	// ExpiresAt UTC Timestamp until when this token is valid. Omitting this field will create a token without an expiry.
	ExpiresAt *time.Time `json:"expires_at"`

	// Scopes Which scopes to grant this token. The given scopes will replace the current scopes, revoking any that are no longer present in the list.
	Scopes *[]interface{} `json:"scopes,omitempty"`
}

// TokenCreateResponse defines model for TokenCreateResponse.
type TokenCreateResponse struct {
	Data *struct {
		Description *string  `json:"description"`
		ExpiresAt   *string  `json:"expires_at"`
		Scopes      []string `json:"scopes"`
		TeamId      string   `json:"team_id"`
		Token       string   `json:"token"`
		TokenId     string   `json:"token_id"`
	} `json:"data,omitempty"`
	Errors  *[]TokenCreateResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                              `json:"success,omitempty"`
}

// TokenCreateResponseErrors0 defines model for .
type TokenCreateResponseErrors0 = string

// TokenCreateResponseErrors1 defines model for .
type TokenCreateResponseErrors1 map[string]interface{}

// TokenCreateResponse_Errors_Item defines model for TokenCreateResponse.errors.Item.
type TokenCreateResponse_Errors_Item struct {
	union json.RawMessage
}

// TokenUpdateRequest Updateable fields for API Tokens. Omitting a field will not update it; explicitly passing null or an empty list will clear the value.
type TokenUpdateRequest struct {
	// DefaultVersion API Version to use, formatted as YYYY-MM-DD
	DefaultVersion *openapi_types.Date `json:"default_version"`

	// Description Description of this token, for instance where it will be used.
	Description *string `json:"description"`

	// ExpiresAt Expiry time of this token. Cannot be set in the past, and cannot be changed for tokens that have already expired. Pass null to make this token never expire.
	ExpiresAt *time.Time `json:"expires_at"`

	// Scopes Which scopes to grant this token. The given scopes will replace the current scopes, revoking any that are no longer present in the list.
	Scopes *[]interface{} `json:"scopes,omitempty"`
}

// TokenUpdateResponse defines model for TokenUpdateResponse.
type TokenUpdateResponse struct {
	Data *struct {
		Description *string    `json:"description"`
		ExpiresAt   *time.Time `json:"expires_at"`
		Scopes      []string   `json:"scopes"`
		TeamId      string     `json:"team_id"`
		TokenId     string     `json:"token_id"`
	} `json:"data,omitempty"`
	Errors  *[]TokenUpdateResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                              `json:"success,omitempty"`
}

// TokenUpdateResponseErrors0 defines model for .
type TokenUpdateResponseErrors0 = string

// TokenUpdateResponseErrors1 defines model for .
type TokenUpdateResponseErrors1 map[string]interface{}

// TokenUpdateResponse_Errors_Item defines model for TokenUpdateResponse.errors.Item.
type TokenUpdateResponse_Errors_Item struct {
	union json.RawMessage
}

// VMCreateSessionRequest defines model for VMCreateSessionRequest.
type VMCreateSessionRequest struct {
	// Permission Permission level for the session
	Permission VMCreateSessionRequestPermission `json:"permission"`

	// SessionId Unique identifier for the session
	SessionId string `json:"session_id"`
}

// VMCreateSessionRequestPermission Permission level for the session
type VMCreateSessionRequestPermission string

// VMCreateSessionResponse defines model for VMCreateSessionResponse.
type VMCreateSessionResponse struct {
	Data *struct {
		// Capabilities List of capabilities that Pitcher has
		Capabilities []string `json:"capabilities"`

		// Permissions The permissions of the current session
		Permissions map[string]interface{} `json:"permissions"`

		// PitcherToken Token to authenticate with Pitcher (the agent running inside the VM)
		PitcherToken string `json:"pitcher_token"`

		// PitcherUrl WebSocket URL to connect to Pitcher
		PitcherUrl string `json:"pitcher_url"`

		// UserWorkspacePath Path to the user's workspace in the VM
		UserWorkspacePath string `json:"user_workspace_path"`

		// Username The Linux username created for this session
		Username string `json:"username"`
	} `json:"data,omitempty"`
	Errors  *[]VMCreateSessionResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                                  `json:"success,omitempty"`
}

// VMCreateSessionResponseErrors0 defines model for .
type VMCreateSessionResponseErrors0 = string

// VMCreateSessionResponseErrors1 defines model for .
type VMCreateSessionResponseErrors1 map[string]interface{}

// VMCreateSessionResponse_Errors_Item defines model for VMCreateSessionResponse.errors.Item.
type VMCreateSessionResponse_Errors_Item struct {
	union json.RawMessage
}

// VMHibernateRequest defines model for VMHibernateRequest.
type VMHibernateRequest = interface{}

// VMHibernateResponse defines model for VMHibernateResponse.
type VMHibernateResponse struct {
	Data    *map[string]interface{}            `json:"data,omitempty"`
	Errors  *[]VMHibernateResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                              `json:"success,omitempty"`
}

// VMHibernateResponseErrors0 defines model for .
type VMHibernateResponseErrors0 = string

// VMHibernateResponseErrors1 defines model for .
type VMHibernateResponseErrors1 map[string]interface{}

// VMHibernateResponse_Errors_Item defines model for VMHibernateResponse.errors.Item.
type VMHibernateResponse_Errors_Item struct {
	union json.RawMessage
}

// VMShutdownRequest defines model for VMShutdownRequest.
type VMShutdownRequest = interface{}

// VMShutdownResponse defines model for VMShutdownResponse.
type VMShutdownResponse struct {
	Data    *map[string]interface{}           `json:"data,omitempty"`
	Errors  *[]VMShutdownResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                             `json:"success,omitempty"`
}

// VMShutdownResponseErrors0 defines model for .
type VMShutdownResponseErrors0 = string

// VMShutdownResponseErrors1 defines model for .
type VMShutdownResponseErrors1 map[string]interface{}

// VMShutdownResponse_Errors_Item defines model for VMShutdownResponse.errors.Item.
type VMShutdownResponse_Errors_Item struct {
	union json.RawMessage
}

// VMStartData defines model for VMStartData.
type VMStartData struct {
	BootupType            string `json:"bootup_type"`
	Cluster               string `json:"cluster"`
	Id                    string `json:"id"`
	LatestPitcherVersion  string `json:"latest_pitcher_version"`
	PitcherManagerVersion string `json:"pitcher_manager_version"`
	PitcherToken          string `json:"pitcher_token"`
	PitcherUrl            string `json:"pitcher_url"`
	PitcherVersion        string `json:"pitcher_version"`
	ReconnectToken        string `json:"reconnect_token"`
	UserWorkspacePath     string `json:"user_workspace_path"`
	WorkspacePath         string `json:"workspace_path"`
}

// VMStartRequest defines model for VMStartRequest.
type VMStartRequest struct {
	// HibernationTimeoutSeconds The time in seconds after which the VM will hibernate due to inactivity.
	// Must be a positive integer between 1 and 86400 (24 hours).
	// Defaults to 300 seconds (5 minutes) if not specified.
	HibernationTimeoutSeconds *int `json:"hibernation_timeout_seconds,omitempty"`

	// Ipcountry This determines in which cluster, closest to the given country the VM will be started in. The format is ISO-3166-1 alpha-2. If not set, the VM will be started closest to the caller of this API. This will only be applied when a VM is run for the first time, and will only serve as a hint (e.g. if the template of this sandbox runs in EU cluster, this sandbox will also run in the EU cluster).
	Ipcountry *string `json:"ipcountry,omitempty"`

	// Tier Determines which specs to start the VM with. If not specified, the VM will start with the default specs for the workspace.
	//
	// You can only specify a VM tier when starting a VM that is inside your workspace. Specifying a VM tier for someone else's sandbox will return an error.
	//
	// Not all tiers will be available depending on the workspace subscription status, and higher tiers incur higher costs. Please see codesandbox.io/pricing for details on specs and costs.
	Tier *interface{} `json:"tier,omitempty"`
}

// VMStartResponse defines model for VMStartResponse.
type VMStartResponse struct {
	Data    *VMStartData                   `json:"data,omitempty"`
	Errors  *[]VMStartResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                          `json:"success,omitempty"`
}

// VMStartResponseErrors0 defines model for .
type VMStartResponseErrors0 = string

// VMStartResponseErrors1 defines model for .
type VMStartResponseErrors1 map[string]interface{}

// VMStartResponse_Errors_Item defines model for VMStartResponse.errors.Item.
type VMStartResponse_Errors_Item struct {
	union json.RawMessage
}

// VMUpdateHibernationTimeoutRequest defines model for VMUpdateHibernationTimeoutRequest.
type VMUpdateHibernationTimeoutRequest struct {
	// HibernationTimeoutSeconds The new hibernation timeout in seconds.
	//
	// Must be greater than 0 and less than or equal to 86400 (24 hours).
	HibernationTimeoutSeconds int `json:"hibernation_timeout_seconds"`
}

// VMUpdateHibernationTimeoutResponse defines model for VMUpdateHibernationTimeoutResponse.
type VMUpdateHibernationTimeoutResponse struct {
	Data *struct {
		HibernationTimeoutSeconds int    `json:"hibernation_timeout_seconds"`
		Id                        string `json:"id"`
	} `json:"data,omitempty"`
	Errors  *[]VMUpdateHibernationTimeoutResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                                             `json:"success,omitempty"`
}

// VMUpdateHibernationTimeoutResponseErrors0 defines model for .
type VMUpdateHibernationTimeoutResponseErrors0 = string

// VMUpdateHibernationTimeoutResponseErrors1 defines model for .
type VMUpdateHibernationTimeoutResponseErrors1 map[string]interface{}

// VMUpdateHibernationTimeoutResponse_Errors_Item defines model for VMUpdateHibernationTimeoutResponse.errors.Item.
type VMUpdateHibernationTimeoutResponse_Errors_Item struct {
	union json.RawMessage
}

// VMUpdateSpecsRequest defines model for VMUpdateSpecsRequest.
type VMUpdateSpecsRequest struct {
	// Tier Determines which specs to update the VM with.
	//
	// Not all tiers will be available depending on the workspace subscription status, and higher tiers incur higher costs. Please see codesandbox.io/pricing for details on specs and costs.
	Tier interface{} `json:"tier"`
}

// VMUpdateSpecsResponse defines model for VMUpdateSpecsResponse.
type VMUpdateSpecsResponse struct {
	Data *struct {
		Id   string `json:"id"`
		Tier string `json:"tier"`
	} `json:"data,omitempty"`
	Errors  *[]VMUpdateSpecsResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                                `json:"success,omitempty"`
}

// VMUpdateSpecsResponseErrors0 defines model for .
type VMUpdateSpecsResponseErrors0 = string

// VMUpdateSpecsResponseErrors1 defines model for .
type VMUpdateSpecsResponseErrors1 map[string]interface{}

// VMUpdateSpecsResponse_Errors_Item defines model for VMUpdateSpecsResponse.errors.Item.
type VMUpdateSpecsResponse_Errors_Item struct {
	union json.RawMessage
}

// WorkspaceCreateRequest defines model for WorkspaceCreateRequest.
type WorkspaceCreateRequest struct {
	// Name Name for the new workspace. Maximum length 64 characters.
	Name string `json:"name"`
}

// WorkspaceCreateResponse defines model for WorkspaceCreateResponse.
type WorkspaceCreateResponse struct {
	Data *struct {
		Id   string `json:"id"`
		Name string `json:"name"`
	} `json:"data,omitempty"`
	Errors  *[]WorkspaceCreateResponse_Errors_Item `json:"errors,omitempty"`
	Success *bool                                  `json:"success,omitempty"`
}

// WorkspaceCreateResponseErrors0 defines model for .
type WorkspaceCreateResponseErrors0 = string

// WorkspaceCreateResponseErrors1 defines model for .
type WorkspaceCreateResponseErrors1 map[string]interface{}

// WorkspaceCreateResponse_Errors_Item defines model for WorkspaceCreateResponse.errors.Item.
type WorkspaceCreateResponse_Errors_Item struct {
	union json.RawMessage
}

// SandboxlistParams defines parameters for Sandboxlist.
type SandboxlistParams struct {
	// Tags Comma-separated list of tags to filter by
	Tags *string `form:"tags,omitempty" json:"tags,omitempty"`

	// OrderBy Field to order results by
	OrderBy *interface{} `form:"order_by,omitempty" json:"order_by,omitempty"`

	// Direction Order direction
	Direction *interface{} `form:"direction,omitempty" json:"direction,omitempty"`

	// PageSize Maximum number of sandboxes to return in a single response
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// Page Page number to return
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Status If true, only returns VMs for which a heartbeat was received in the last 30 seconds.
	Status *interface{} `form:"status,omitempty" json:"status,omitempty"`
}

// WorkspacecreateJSONRequestBody defines body for Workspacecreate for application/json ContentType.
type WorkspacecreateJSONRequestBody = WorkspaceCreateRequest

// TokencreateJSONRequestBody defines body for Tokencreate for application/json ContentType.
type TokencreateJSONRequestBody = TokenCreateRequest

// TokenupdateJSONRequestBody defines body for Tokenupdate for application/json ContentType.
type TokenupdateJSONRequestBody = TokenUpdateRequest

// SandboxcreateJSONRequestBody defines body for Sandboxcreate for application/json ContentType.
type SandboxcreateJSONRequestBody = SandboxCreateRequest

// SandboxforkJSONRequestBody defines body for Sandboxfork for application/json ContentType.
type SandboxforkJSONRequestBody = SandboxForkRequest

// VmhibernateJSONRequestBody defines body for Vmhibernate for application/json ContentType.
type VmhibernateJSONRequestBody = VMHibernateRequest

// VmupdateHibernationTimeoutJSONRequestBody defines body for VmupdateHibernationTimeout for application/json ContentType.
type VmupdateHibernationTimeoutJSONRequestBody = VMUpdateHibernationTimeoutRequest

// VmcreateSessionJSONRequestBody defines body for VmcreateSession for application/json ContentType.
type VmcreateSessionJSONRequestBody = VMCreateSessionRequest

// VmshutdownJSONRequestBody defines body for Vmshutdown for application/json ContentType.
type VmshutdownJSONRequestBody = VMShutdownRequest

// VmupdateSpecsJSONRequestBody defines body for VmupdateSpecs for application/json ContentType.
type VmupdateSpecsJSONRequestBody = VMUpdateSpecsRequest

// VmstartJSONRequestBody defines body for Vmstart for application/json ContentType.
type VmstartJSONRequestBody = VMStartRequest

// VmupdateSpecs2JSONRequestBody defines body for VmupdateSpecs2 for application/json ContentType.
type VmupdateSpecs2JSONRequestBody = VMUpdateSpecsRequest

// AsSandboxCreateResponseErrors0 returns the union data inside the SandboxCreateResponse_Errors_Item as a SandboxCreateResponseErrors0
func (t SandboxCreateResponse_Errors_Item) AsSandboxCreateResponseErrors0() (SandboxCreateResponseErrors0, error) {
	var body SandboxCreateResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSandboxCreateResponseErrors0 overwrites any union data inside the SandboxCreateResponse_Errors_Item as the provided SandboxCreateResponseErrors0
func (t *SandboxCreateResponse_Errors_Item) FromSandboxCreateResponseErrors0(v SandboxCreateResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSandboxCreateResponseErrors0 performs a merge with any union data inside the SandboxCreateResponse_Errors_Item, using the provided SandboxCreateResponseErrors0
func (t *SandboxCreateResponse_Errors_Item) MergeSandboxCreateResponseErrors0(v SandboxCreateResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSandboxCreateResponseErrors1 returns the union data inside the SandboxCreateResponse_Errors_Item as a SandboxCreateResponseErrors1
func (t SandboxCreateResponse_Errors_Item) AsSandboxCreateResponseErrors1() (SandboxCreateResponseErrors1, error) {
	var body SandboxCreateResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSandboxCreateResponseErrors1 overwrites any union data inside the SandboxCreateResponse_Errors_Item as the provided SandboxCreateResponseErrors1
func (t *SandboxCreateResponse_Errors_Item) FromSandboxCreateResponseErrors1(v SandboxCreateResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSandboxCreateResponseErrors1 performs a merge with any union data inside the SandboxCreateResponse_Errors_Item, using the provided SandboxCreateResponseErrors1
func (t *SandboxCreateResponse_Errors_Item) MergeSandboxCreateResponseErrors1(v SandboxCreateResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SandboxCreateResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SandboxCreateResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSandboxForkResponseErrors0 returns the union data inside the SandboxForkResponse_Errors_Item as a SandboxForkResponseErrors0
func (t SandboxForkResponse_Errors_Item) AsSandboxForkResponseErrors0() (SandboxForkResponseErrors0, error) {
	var body SandboxForkResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSandboxForkResponseErrors0 overwrites any union data inside the SandboxForkResponse_Errors_Item as the provided SandboxForkResponseErrors0
func (t *SandboxForkResponse_Errors_Item) FromSandboxForkResponseErrors0(v SandboxForkResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSandboxForkResponseErrors0 performs a merge with any union data inside the SandboxForkResponse_Errors_Item, using the provided SandboxForkResponseErrors0
func (t *SandboxForkResponse_Errors_Item) MergeSandboxForkResponseErrors0(v SandboxForkResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSandboxForkResponseErrors1 returns the union data inside the SandboxForkResponse_Errors_Item as a SandboxForkResponseErrors1
func (t SandboxForkResponse_Errors_Item) AsSandboxForkResponseErrors1() (SandboxForkResponseErrors1, error) {
	var body SandboxForkResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSandboxForkResponseErrors1 overwrites any union data inside the SandboxForkResponse_Errors_Item as the provided SandboxForkResponseErrors1
func (t *SandboxForkResponse_Errors_Item) FromSandboxForkResponseErrors1(v SandboxForkResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSandboxForkResponseErrors1 performs a merge with any union data inside the SandboxForkResponse_Errors_Item, using the provided SandboxForkResponseErrors1
func (t *SandboxForkResponse_Errors_Item) MergeSandboxForkResponseErrors1(v SandboxForkResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SandboxForkResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SandboxForkResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSandboxGetResponseErrors0 returns the union data inside the SandboxGetResponse_Errors_Item as a SandboxGetResponseErrors0
func (t SandboxGetResponse_Errors_Item) AsSandboxGetResponseErrors0() (SandboxGetResponseErrors0, error) {
	var body SandboxGetResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSandboxGetResponseErrors0 overwrites any union data inside the SandboxGetResponse_Errors_Item as the provided SandboxGetResponseErrors0
func (t *SandboxGetResponse_Errors_Item) FromSandboxGetResponseErrors0(v SandboxGetResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSandboxGetResponseErrors0 performs a merge with any union data inside the SandboxGetResponse_Errors_Item, using the provided SandboxGetResponseErrors0
func (t *SandboxGetResponse_Errors_Item) MergeSandboxGetResponseErrors0(v SandboxGetResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSandboxGetResponseErrors1 returns the union data inside the SandboxGetResponse_Errors_Item as a SandboxGetResponseErrors1
func (t SandboxGetResponse_Errors_Item) AsSandboxGetResponseErrors1() (SandboxGetResponseErrors1, error) {
	var body SandboxGetResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSandboxGetResponseErrors1 overwrites any union data inside the SandboxGetResponse_Errors_Item as the provided SandboxGetResponseErrors1
func (t *SandboxGetResponse_Errors_Item) FromSandboxGetResponseErrors1(v SandboxGetResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSandboxGetResponseErrors1 performs a merge with any union data inside the SandboxGetResponse_Errors_Item, using the provided SandboxGetResponseErrors1
func (t *SandboxGetResponse_Errors_Item) MergeSandboxGetResponseErrors1(v SandboxGetResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SandboxGetResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SandboxGetResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSandboxListResponseErrors0 returns the union data inside the SandboxListResponse_Errors_Item as a SandboxListResponseErrors0
func (t SandboxListResponse_Errors_Item) AsSandboxListResponseErrors0() (SandboxListResponseErrors0, error) {
	var body SandboxListResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSandboxListResponseErrors0 overwrites any union data inside the SandboxListResponse_Errors_Item as the provided SandboxListResponseErrors0
func (t *SandboxListResponse_Errors_Item) FromSandboxListResponseErrors0(v SandboxListResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSandboxListResponseErrors0 performs a merge with any union data inside the SandboxListResponse_Errors_Item, using the provided SandboxListResponseErrors0
func (t *SandboxListResponse_Errors_Item) MergeSandboxListResponseErrors0(v SandboxListResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSandboxListResponseErrors1 returns the union data inside the SandboxListResponse_Errors_Item as a SandboxListResponseErrors1
func (t SandboxListResponse_Errors_Item) AsSandboxListResponseErrors1() (SandboxListResponseErrors1, error) {
	var body SandboxListResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSandboxListResponseErrors1 overwrites any union data inside the SandboxListResponse_Errors_Item as the provided SandboxListResponseErrors1
func (t *SandboxListResponse_Errors_Item) FromSandboxListResponseErrors1(v SandboxListResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSandboxListResponseErrors1 performs a merge with any union data inside the SandboxListResponse_Errors_Item, using the provided SandboxListResponseErrors1
func (t *SandboxListResponse_Errors_Item) MergeSandboxListResponseErrors1(v SandboxListResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SandboxListResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SandboxListResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTokenCreateResponseErrors0 returns the union data inside the TokenCreateResponse_Errors_Item as a TokenCreateResponseErrors0
func (t TokenCreateResponse_Errors_Item) AsTokenCreateResponseErrors0() (TokenCreateResponseErrors0, error) {
	var body TokenCreateResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTokenCreateResponseErrors0 overwrites any union data inside the TokenCreateResponse_Errors_Item as the provided TokenCreateResponseErrors0
func (t *TokenCreateResponse_Errors_Item) FromTokenCreateResponseErrors0(v TokenCreateResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTokenCreateResponseErrors0 performs a merge with any union data inside the TokenCreateResponse_Errors_Item, using the provided TokenCreateResponseErrors0
func (t *TokenCreateResponse_Errors_Item) MergeTokenCreateResponseErrors0(v TokenCreateResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTokenCreateResponseErrors1 returns the union data inside the TokenCreateResponse_Errors_Item as a TokenCreateResponseErrors1
func (t TokenCreateResponse_Errors_Item) AsTokenCreateResponseErrors1() (TokenCreateResponseErrors1, error) {
	var body TokenCreateResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTokenCreateResponseErrors1 overwrites any union data inside the TokenCreateResponse_Errors_Item as the provided TokenCreateResponseErrors1
func (t *TokenCreateResponse_Errors_Item) FromTokenCreateResponseErrors1(v TokenCreateResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTokenCreateResponseErrors1 performs a merge with any union data inside the TokenCreateResponse_Errors_Item, using the provided TokenCreateResponseErrors1
func (t *TokenCreateResponse_Errors_Item) MergeTokenCreateResponseErrors1(v TokenCreateResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TokenCreateResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TokenCreateResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTokenUpdateResponseErrors0 returns the union data inside the TokenUpdateResponse_Errors_Item as a TokenUpdateResponseErrors0
func (t TokenUpdateResponse_Errors_Item) AsTokenUpdateResponseErrors0() (TokenUpdateResponseErrors0, error) {
	var body TokenUpdateResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTokenUpdateResponseErrors0 overwrites any union data inside the TokenUpdateResponse_Errors_Item as the provided TokenUpdateResponseErrors0
func (t *TokenUpdateResponse_Errors_Item) FromTokenUpdateResponseErrors0(v TokenUpdateResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTokenUpdateResponseErrors0 performs a merge with any union data inside the TokenUpdateResponse_Errors_Item, using the provided TokenUpdateResponseErrors0
func (t *TokenUpdateResponse_Errors_Item) MergeTokenUpdateResponseErrors0(v TokenUpdateResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTokenUpdateResponseErrors1 returns the union data inside the TokenUpdateResponse_Errors_Item as a TokenUpdateResponseErrors1
func (t TokenUpdateResponse_Errors_Item) AsTokenUpdateResponseErrors1() (TokenUpdateResponseErrors1, error) {
	var body TokenUpdateResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTokenUpdateResponseErrors1 overwrites any union data inside the TokenUpdateResponse_Errors_Item as the provided TokenUpdateResponseErrors1
func (t *TokenUpdateResponse_Errors_Item) FromTokenUpdateResponseErrors1(v TokenUpdateResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTokenUpdateResponseErrors1 performs a merge with any union data inside the TokenUpdateResponse_Errors_Item, using the provided TokenUpdateResponseErrors1
func (t *TokenUpdateResponse_Errors_Item) MergeTokenUpdateResponseErrors1(v TokenUpdateResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TokenUpdateResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TokenUpdateResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVMCreateSessionResponseErrors0 returns the union data inside the VMCreateSessionResponse_Errors_Item as a VMCreateSessionResponseErrors0
func (t VMCreateSessionResponse_Errors_Item) AsVMCreateSessionResponseErrors0() (VMCreateSessionResponseErrors0, error) {
	var body VMCreateSessionResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMCreateSessionResponseErrors0 overwrites any union data inside the VMCreateSessionResponse_Errors_Item as the provided VMCreateSessionResponseErrors0
func (t *VMCreateSessionResponse_Errors_Item) FromVMCreateSessionResponseErrors0(v VMCreateSessionResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMCreateSessionResponseErrors0 performs a merge with any union data inside the VMCreateSessionResponse_Errors_Item, using the provided VMCreateSessionResponseErrors0
func (t *VMCreateSessionResponse_Errors_Item) MergeVMCreateSessionResponseErrors0(v VMCreateSessionResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVMCreateSessionResponseErrors1 returns the union data inside the VMCreateSessionResponse_Errors_Item as a VMCreateSessionResponseErrors1
func (t VMCreateSessionResponse_Errors_Item) AsVMCreateSessionResponseErrors1() (VMCreateSessionResponseErrors1, error) {
	var body VMCreateSessionResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMCreateSessionResponseErrors1 overwrites any union data inside the VMCreateSessionResponse_Errors_Item as the provided VMCreateSessionResponseErrors1
func (t *VMCreateSessionResponse_Errors_Item) FromVMCreateSessionResponseErrors1(v VMCreateSessionResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMCreateSessionResponseErrors1 performs a merge with any union data inside the VMCreateSessionResponse_Errors_Item, using the provided VMCreateSessionResponseErrors1
func (t *VMCreateSessionResponse_Errors_Item) MergeVMCreateSessionResponseErrors1(v VMCreateSessionResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t VMCreateSessionResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VMCreateSessionResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVMHibernateResponseErrors0 returns the union data inside the VMHibernateResponse_Errors_Item as a VMHibernateResponseErrors0
func (t VMHibernateResponse_Errors_Item) AsVMHibernateResponseErrors0() (VMHibernateResponseErrors0, error) {
	var body VMHibernateResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMHibernateResponseErrors0 overwrites any union data inside the VMHibernateResponse_Errors_Item as the provided VMHibernateResponseErrors0
func (t *VMHibernateResponse_Errors_Item) FromVMHibernateResponseErrors0(v VMHibernateResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMHibernateResponseErrors0 performs a merge with any union data inside the VMHibernateResponse_Errors_Item, using the provided VMHibernateResponseErrors0
func (t *VMHibernateResponse_Errors_Item) MergeVMHibernateResponseErrors0(v VMHibernateResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVMHibernateResponseErrors1 returns the union data inside the VMHibernateResponse_Errors_Item as a VMHibernateResponseErrors1
func (t VMHibernateResponse_Errors_Item) AsVMHibernateResponseErrors1() (VMHibernateResponseErrors1, error) {
	var body VMHibernateResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMHibernateResponseErrors1 overwrites any union data inside the VMHibernateResponse_Errors_Item as the provided VMHibernateResponseErrors1
func (t *VMHibernateResponse_Errors_Item) FromVMHibernateResponseErrors1(v VMHibernateResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMHibernateResponseErrors1 performs a merge with any union data inside the VMHibernateResponse_Errors_Item, using the provided VMHibernateResponseErrors1
func (t *VMHibernateResponse_Errors_Item) MergeVMHibernateResponseErrors1(v VMHibernateResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t VMHibernateResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VMHibernateResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVMShutdownResponseErrors0 returns the union data inside the VMShutdownResponse_Errors_Item as a VMShutdownResponseErrors0
func (t VMShutdownResponse_Errors_Item) AsVMShutdownResponseErrors0() (VMShutdownResponseErrors0, error) {
	var body VMShutdownResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMShutdownResponseErrors0 overwrites any union data inside the VMShutdownResponse_Errors_Item as the provided VMShutdownResponseErrors0
func (t *VMShutdownResponse_Errors_Item) FromVMShutdownResponseErrors0(v VMShutdownResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMShutdownResponseErrors0 performs a merge with any union data inside the VMShutdownResponse_Errors_Item, using the provided VMShutdownResponseErrors0
func (t *VMShutdownResponse_Errors_Item) MergeVMShutdownResponseErrors0(v VMShutdownResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVMShutdownResponseErrors1 returns the union data inside the VMShutdownResponse_Errors_Item as a VMShutdownResponseErrors1
func (t VMShutdownResponse_Errors_Item) AsVMShutdownResponseErrors1() (VMShutdownResponseErrors1, error) {
	var body VMShutdownResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMShutdownResponseErrors1 overwrites any union data inside the VMShutdownResponse_Errors_Item as the provided VMShutdownResponseErrors1
func (t *VMShutdownResponse_Errors_Item) FromVMShutdownResponseErrors1(v VMShutdownResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMShutdownResponseErrors1 performs a merge with any union data inside the VMShutdownResponse_Errors_Item, using the provided VMShutdownResponseErrors1
func (t *VMShutdownResponse_Errors_Item) MergeVMShutdownResponseErrors1(v VMShutdownResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t VMShutdownResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VMShutdownResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVMStartResponseErrors0 returns the union data inside the VMStartResponse_Errors_Item as a VMStartResponseErrors0
func (t VMStartResponse_Errors_Item) AsVMStartResponseErrors0() (VMStartResponseErrors0, error) {
	var body VMStartResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMStartResponseErrors0 overwrites any union data inside the VMStartResponse_Errors_Item as the provided VMStartResponseErrors0
func (t *VMStartResponse_Errors_Item) FromVMStartResponseErrors0(v VMStartResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMStartResponseErrors0 performs a merge with any union data inside the VMStartResponse_Errors_Item, using the provided VMStartResponseErrors0
func (t *VMStartResponse_Errors_Item) MergeVMStartResponseErrors0(v VMStartResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVMStartResponseErrors1 returns the union data inside the VMStartResponse_Errors_Item as a VMStartResponseErrors1
func (t VMStartResponse_Errors_Item) AsVMStartResponseErrors1() (VMStartResponseErrors1, error) {
	var body VMStartResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMStartResponseErrors1 overwrites any union data inside the VMStartResponse_Errors_Item as the provided VMStartResponseErrors1
func (t *VMStartResponse_Errors_Item) FromVMStartResponseErrors1(v VMStartResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMStartResponseErrors1 performs a merge with any union data inside the VMStartResponse_Errors_Item, using the provided VMStartResponseErrors1
func (t *VMStartResponse_Errors_Item) MergeVMStartResponseErrors1(v VMStartResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t VMStartResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VMStartResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVMUpdateHibernationTimeoutResponseErrors0 returns the union data inside the VMUpdateHibernationTimeoutResponse_Errors_Item as a VMUpdateHibernationTimeoutResponseErrors0
func (t VMUpdateHibernationTimeoutResponse_Errors_Item) AsVMUpdateHibernationTimeoutResponseErrors0() (VMUpdateHibernationTimeoutResponseErrors0, error) {
	var body VMUpdateHibernationTimeoutResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMUpdateHibernationTimeoutResponseErrors0 overwrites any union data inside the VMUpdateHibernationTimeoutResponse_Errors_Item as the provided VMUpdateHibernationTimeoutResponseErrors0
func (t *VMUpdateHibernationTimeoutResponse_Errors_Item) FromVMUpdateHibernationTimeoutResponseErrors0(v VMUpdateHibernationTimeoutResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMUpdateHibernationTimeoutResponseErrors0 performs a merge with any union data inside the VMUpdateHibernationTimeoutResponse_Errors_Item, using the provided VMUpdateHibernationTimeoutResponseErrors0
func (t *VMUpdateHibernationTimeoutResponse_Errors_Item) MergeVMUpdateHibernationTimeoutResponseErrors0(v VMUpdateHibernationTimeoutResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVMUpdateHibernationTimeoutResponseErrors1 returns the union data inside the VMUpdateHibernationTimeoutResponse_Errors_Item as a VMUpdateHibernationTimeoutResponseErrors1
func (t VMUpdateHibernationTimeoutResponse_Errors_Item) AsVMUpdateHibernationTimeoutResponseErrors1() (VMUpdateHibernationTimeoutResponseErrors1, error) {
	var body VMUpdateHibernationTimeoutResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMUpdateHibernationTimeoutResponseErrors1 overwrites any union data inside the VMUpdateHibernationTimeoutResponse_Errors_Item as the provided VMUpdateHibernationTimeoutResponseErrors1
func (t *VMUpdateHibernationTimeoutResponse_Errors_Item) FromVMUpdateHibernationTimeoutResponseErrors1(v VMUpdateHibernationTimeoutResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMUpdateHibernationTimeoutResponseErrors1 performs a merge with any union data inside the VMUpdateHibernationTimeoutResponse_Errors_Item, using the provided VMUpdateHibernationTimeoutResponseErrors1
func (t *VMUpdateHibernationTimeoutResponse_Errors_Item) MergeVMUpdateHibernationTimeoutResponseErrors1(v VMUpdateHibernationTimeoutResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t VMUpdateHibernationTimeoutResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VMUpdateHibernationTimeoutResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVMUpdateSpecsResponseErrors0 returns the union data inside the VMUpdateSpecsResponse_Errors_Item as a VMUpdateSpecsResponseErrors0
func (t VMUpdateSpecsResponse_Errors_Item) AsVMUpdateSpecsResponseErrors0() (VMUpdateSpecsResponseErrors0, error) {
	var body VMUpdateSpecsResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMUpdateSpecsResponseErrors0 overwrites any union data inside the VMUpdateSpecsResponse_Errors_Item as the provided VMUpdateSpecsResponseErrors0
func (t *VMUpdateSpecsResponse_Errors_Item) FromVMUpdateSpecsResponseErrors0(v VMUpdateSpecsResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMUpdateSpecsResponseErrors0 performs a merge with any union data inside the VMUpdateSpecsResponse_Errors_Item, using the provided VMUpdateSpecsResponseErrors0
func (t *VMUpdateSpecsResponse_Errors_Item) MergeVMUpdateSpecsResponseErrors0(v VMUpdateSpecsResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVMUpdateSpecsResponseErrors1 returns the union data inside the VMUpdateSpecsResponse_Errors_Item as a VMUpdateSpecsResponseErrors1
func (t VMUpdateSpecsResponse_Errors_Item) AsVMUpdateSpecsResponseErrors1() (VMUpdateSpecsResponseErrors1, error) {
	var body VMUpdateSpecsResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMUpdateSpecsResponseErrors1 overwrites any union data inside the VMUpdateSpecsResponse_Errors_Item as the provided VMUpdateSpecsResponseErrors1
func (t *VMUpdateSpecsResponse_Errors_Item) FromVMUpdateSpecsResponseErrors1(v VMUpdateSpecsResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMUpdateSpecsResponseErrors1 performs a merge with any union data inside the VMUpdateSpecsResponse_Errors_Item, using the provided VMUpdateSpecsResponseErrors1
func (t *VMUpdateSpecsResponse_Errors_Item) MergeVMUpdateSpecsResponseErrors1(v VMUpdateSpecsResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t VMUpdateSpecsResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VMUpdateSpecsResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsWorkspaceCreateResponseErrors0 returns the union data inside the WorkspaceCreateResponse_Errors_Item as a WorkspaceCreateResponseErrors0
func (t WorkspaceCreateResponse_Errors_Item) AsWorkspaceCreateResponseErrors0() (WorkspaceCreateResponseErrors0, error) {
	var body WorkspaceCreateResponseErrors0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWorkspaceCreateResponseErrors0 overwrites any union data inside the WorkspaceCreateResponse_Errors_Item as the provided WorkspaceCreateResponseErrors0
func (t *WorkspaceCreateResponse_Errors_Item) FromWorkspaceCreateResponseErrors0(v WorkspaceCreateResponseErrors0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWorkspaceCreateResponseErrors0 performs a merge with any union data inside the WorkspaceCreateResponse_Errors_Item, using the provided WorkspaceCreateResponseErrors0
func (t *WorkspaceCreateResponse_Errors_Item) MergeWorkspaceCreateResponseErrors0(v WorkspaceCreateResponseErrors0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWorkspaceCreateResponseErrors1 returns the union data inside the WorkspaceCreateResponse_Errors_Item as a WorkspaceCreateResponseErrors1
func (t WorkspaceCreateResponse_Errors_Item) AsWorkspaceCreateResponseErrors1() (WorkspaceCreateResponseErrors1, error) {
	var body WorkspaceCreateResponseErrors1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWorkspaceCreateResponseErrors1 overwrites any union data inside the WorkspaceCreateResponse_Errors_Item as the provided WorkspaceCreateResponseErrors1
func (t *WorkspaceCreateResponse_Errors_Item) FromWorkspaceCreateResponseErrors1(v WorkspaceCreateResponseErrors1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWorkspaceCreateResponseErrors1 performs a merge with any union data inside the WorkspaceCreateResponse_Errors_Item, using the provided WorkspaceCreateResponseErrors1
func (t *WorkspaceCreateResponse_Errors_Item) MergeWorkspaceCreateResponseErrors1(v WorkspaceCreateResponseErrors1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t WorkspaceCreateResponse_Errors_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *WorkspaceCreateResponse_Errors_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// Metainfo request
	Metainfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkspacecreateWithBody request with any body
	WorkspacecreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Workspacecreate(ctx context.Context, body WorkspacecreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TokencreateWithBody request with any body
	TokencreateWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Tokencreate(ctx context.Context, teamId string, body TokencreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TokenupdateWithBody request with any body
	TokenupdateWithBody(ctx context.Context, teamId string, tokenId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Tokenupdate(ctx context.Context, teamId string, tokenId string, body TokenupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Sandboxlist request
	Sandboxlist(ctx context.Context, params *SandboxlistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SandboxcreateWithBody request with any body
	SandboxcreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Sandboxcreate(ctx context.Context, body SandboxcreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Sandboxget request
	Sandboxget(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SandboxforkWithBody request with any body
	SandboxforkWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Sandboxfork(ctx context.Context, id string, body SandboxforkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VmhibernateWithBody request with any body
	VmhibernateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Vmhibernate(ctx context.Context, id string, body VmhibernateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VmupdateHibernationTimeoutWithBody request with any body
	VmupdateHibernationTimeoutWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VmupdateHibernationTimeout(ctx context.Context, id string, body VmupdateHibernationTimeoutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VmcreateSessionWithBody request with any body
	VmcreateSessionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VmcreateSession(ctx context.Context, id string, body VmcreateSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VmshutdownWithBody request with any body
	VmshutdownWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Vmshutdown(ctx context.Context, id string, body VmshutdownJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VmupdateSpecsWithBody request with any body
	VmupdateSpecsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VmupdateSpecs(ctx context.Context, id string, body VmupdateSpecsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VmstartWithBody request with any body
	VmstartWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Vmstart(ctx context.Context, id string, body VmstartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VmupdateSpecs2WithBody request with any body
	VmupdateSpecs2WithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VmupdateSpecs2(ctx context.Context, id string, body VmupdateSpecs2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) Metainfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetainfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkspacecreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkspacecreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Workspacecreate(ctx context.Context, body WorkspacecreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkspacecreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TokencreateWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTokencreateRequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Tokencreate(ctx context.Context, teamId string, body TokencreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTokencreateRequest(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TokenupdateWithBody(ctx context.Context, teamId string, tokenId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTokenupdateRequestWithBody(c.Server, teamId, tokenId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Tokenupdate(ctx context.Context, teamId string, tokenId string, body TokenupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTokenupdateRequest(c.Server, teamId, tokenId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Sandboxlist(ctx context.Context, params *SandboxlistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSandboxlistRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SandboxcreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSandboxcreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Sandboxcreate(ctx context.Context, body SandboxcreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSandboxcreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Sandboxget(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSandboxgetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SandboxforkWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSandboxforkRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Sandboxfork(ctx context.Context, id string, body SandboxforkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSandboxforkRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VmhibernateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmhibernateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Vmhibernate(ctx context.Context, id string, body VmhibernateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmhibernateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VmupdateHibernationTimeoutWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmupdateHibernationTimeoutRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VmupdateHibernationTimeout(ctx context.Context, id string, body VmupdateHibernationTimeoutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmupdateHibernationTimeoutRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VmcreateSessionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmcreateSessionRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VmcreateSession(ctx context.Context, id string, body VmcreateSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmcreateSessionRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VmshutdownWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmshutdownRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Vmshutdown(ctx context.Context, id string, body VmshutdownJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmshutdownRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VmupdateSpecsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmupdateSpecsRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VmupdateSpecs(ctx context.Context, id string, body VmupdateSpecsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmupdateSpecsRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VmstartWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmstartRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Vmstart(ctx context.Context, id string, body VmstartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmstartRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VmupdateSpecs2WithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmupdateSpecs2RequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VmupdateSpecs2(ctx context.Context, id string, body VmupdateSpecs2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVmupdateSpecs2Request(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewMetainfoRequest generates requests for Metainfo
func NewMetainfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meta/info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkspacecreateRequest calls the generic Workspacecreate builder with application/json body
func NewWorkspacecreateRequest(server string, body WorkspacecreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWorkspacecreateRequestWithBody(server, "application/json", bodyReader)
}

// NewWorkspacecreateRequestWithBody generates requests for Workspacecreate with any type of body
func NewWorkspacecreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/workspace")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTokencreateRequest calls the generic Tokencreate builder with application/json body
func NewTokencreateRequest(server string, teamId string, body TokencreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTokencreateRequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewTokencreateRequestWithBody generates requests for Tokencreate with any type of body
func NewTokencreateRequestWithBody(server string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/workspace/%s/tokens", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTokenupdateRequest calls the generic Tokenupdate builder with application/json body
func NewTokenupdateRequest(server string, teamId string, tokenId string, body TokenupdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTokenupdateRequestWithBody(server, teamId, tokenId, "application/json", bodyReader)
}

// NewTokenupdateRequestWithBody generates requests for Tokenupdate with any type of body
func NewTokenupdateRequestWithBody(server string, teamId string, tokenId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "token_id", runtime.ParamLocationPath, tokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/org/workspace/%s/tokens/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSandboxlistRequest generates requests for Sandboxlist
func NewSandboxlistRequest(server string, params *SandboxlistParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandbox")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSandboxcreateRequest calls the generic Sandboxcreate builder with application/json body
func NewSandboxcreateRequest(server string, body SandboxcreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSandboxcreateRequestWithBody(server, "application/json", bodyReader)
}

// NewSandboxcreateRequestWithBody generates requests for Sandboxcreate with any type of body
func NewSandboxcreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandbox")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSandboxgetRequest generates requests for Sandboxget
func NewSandboxgetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandbox/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSandboxforkRequest calls the generic Sandboxfork builder with application/json body
func NewSandboxforkRequest(server string, id string, body SandboxforkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSandboxforkRequestWithBody(server, id, "application/json", bodyReader)
}

// NewSandboxforkRequestWithBody generates requests for Sandboxfork with any type of body
func NewSandboxforkRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandbox/%s/fork", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVmhibernateRequest calls the generic Vmhibernate builder with application/json body
func NewVmhibernateRequest(server string, id string, body VmhibernateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVmhibernateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewVmhibernateRequestWithBody generates requests for Vmhibernate with any type of body
func NewVmhibernateRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vm/%s/hibernate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVmupdateHibernationTimeoutRequest calls the generic VmupdateHibernationTimeout builder with application/json body
func NewVmupdateHibernationTimeoutRequest(server string, id string, body VmupdateHibernationTimeoutJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVmupdateHibernationTimeoutRequestWithBody(server, id, "application/json", bodyReader)
}

// NewVmupdateHibernationTimeoutRequestWithBody generates requests for VmupdateHibernationTimeout with any type of body
func NewVmupdateHibernationTimeoutRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vm/%s/hibernation_timeout", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVmcreateSessionRequest calls the generic VmcreateSession builder with application/json body
func NewVmcreateSessionRequest(server string, id string, body VmcreateSessionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVmcreateSessionRequestWithBody(server, id, "application/json", bodyReader)
}

// NewVmcreateSessionRequestWithBody generates requests for VmcreateSession with any type of body
func NewVmcreateSessionRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vm/%s/sessions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVmshutdownRequest calls the generic Vmshutdown builder with application/json body
func NewVmshutdownRequest(server string, id string, body VmshutdownJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVmshutdownRequestWithBody(server, id, "application/json", bodyReader)
}

// NewVmshutdownRequestWithBody generates requests for Vmshutdown with any type of body
func NewVmshutdownRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vm/%s/shutdown", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVmupdateSpecsRequest calls the generic VmupdateSpecs builder with application/json body
func NewVmupdateSpecsRequest(server string, id string, body VmupdateSpecsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVmupdateSpecsRequestWithBody(server, id, "application/json", bodyReader)
}

// NewVmupdateSpecsRequestWithBody generates requests for VmupdateSpecs with any type of body
func NewVmupdateSpecsRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vm/%s/specs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVmstartRequest calls the generic Vmstart builder with application/json body
func NewVmstartRequest(server string, id string, body VmstartJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVmstartRequestWithBody(server, id, "application/json", bodyReader)
}

// NewVmstartRequestWithBody generates requests for Vmstart with any type of body
func NewVmstartRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vm/%s/start", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVmupdateSpecs2Request calls the generic VmupdateSpecs2 builder with application/json body
func NewVmupdateSpecs2Request(server string, id string, body VmupdateSpecs2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVmupdateSpecs2RequestWithBody(server, id, "application/json", bodyReader)
}

// NewVmupdateSpecs2RequestWithBody generates requests for VmupdateSpecs2 with any type of body
func NewVmupdateSpecs2RequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vm/%s/update_specs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// MetainfoWithResponse request
	MetainfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MetainfoResponse, error)

	// WorkspacecreateWithBodyWithResponse request with any body
	WorkspacecreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorkspacecreateResponse, error)

	WorkspacecreateWithResponse(ctx context.Context, body WorkspacecreateJSONRequestBody, reqEditors ...RequestEditorFn) (*WorkspacecreateResponse, error)

	// TokencreateWithBodyWithResponse request with any body
	TokencreateWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TokencreateResponse, error)

	TokencreateWithResponse(ctx context.Context, teamId string, body TokencreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TokencreateResponse, error)

	// TokenupdateWithBodyWithResponse request with any body
	TokenupdateWithBodyWithResponse(ctx context.Context, teamId string, tokenId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TokenupdateResponse, error)

	TokenupdateWithResponse(ctx context.Context, teamId string, tokenId string, body TokenupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TokenupdateResponse, error)

	// SandboxlistWithResponse request
	SandboxlistWithResponse(ctx context.Context, params *SandboxlistParams, reqEditors ...RequestEditorFn) (*SandboxlistResponse, error)

	// SandboxcreateWithBodyWithResponse request with any body
	SandboxcreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SandboxcreateResponse, error)

	SandboxcreateWithResponse(ctx context.Context, body SandboxcreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SandboxcreateResponse, error)

	// SandboxgetWithResponse request
	SandboxgetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SandboxgetResponse, error)

	// SandboxforkWithBodyWithResponse request with any body
	SandboxforkWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SandboxforkResponse, error)

	SandboxforkWithResponse(ctx context.Context, id string, body SandboxforkJSONRequestBody, reqEditors ...RequestEditorFn) (*SandboxforkResponse, error)

	// VmhibernateWithBodyWithResponse request with any body
	VmhibernateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VmhibernateResponse, error)

	VmhibernateWithResponse(ctx context.Context, id string, body VmhibernateJSONRequestBody, reqEditors ...RequestEditorFn) (*VmhibernateResponse, error)

	// VmupdateHibernationTimeoutWithBodyWithResponse request with any body
	VmupdateHibernationTimeoutWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VmupdateHibernationTimeoutResponse, error)

	VmupdateHibernationTimeoutWithResponse(ctx context.Context, id string, body VmupdateHibernationTimeoutJSONRequestBody, reqEditors ...RequestEditorFn) (*VmupdateHibernationTimeoutResponse, error)

	// VmcreateSessionWithBodyWithResponse request with any body
	VmcreateSessionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VmcreateSessionResponse, error)

	VmcreateSessionWithResponse(ctx context.Context, id string, body VmcreateSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*VmcreateSessionResponse, error)

	// VmshutdownWithBodyWithResponse request with any body
	VmshutdownWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VmshutdownResponse, error)

	VmshutdownWithResponse(ctx context.Context, id string, body VmshutdownJSONRequestBody, reqEditors ...RequestEditorFn) (*VmshutdownResponse, error)

	// VmupdateSpecsWithBodyWithResponse request with any body
	VmupdateSpecsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VmupdateSpecsResponse, error)

	VmupdateSpecsWithResponse(ctx context.Context, id string, body VmupdateSpecsJSONRequestBody, reqEditors ...RequestEditorFn) (*VmupdateSpecsResponse, error)

	// VmstartWithBodyWithResponse request with any body
	VmstartWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VmstartResponse, error)

	VmstartWithResponse(ctx context.Context, id string, body VmstartJSONRequestBody, reqEditors ...RequestEditorFn) (*VmstartResponse, error)

	// VmupdateSpecs2WithBodyWithResponse request with any body
	VmupdateSpecs2WithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VmupdateSpecs2Response, error)

	VmupdateSpecs2WithResponse(ctx context.Context, id string, body VmupdateSpecs2JSONRequestBody, reqEditors ...RequestEditorFn) (*VmupdateSpecs2Response, error)
}

type MetainfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetaInformation
}

// Status returns HTTPResponse.Status
func (r MetainfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetainfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkspacecreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *WorkspaceCreateResponse
}

// Status returns HTTPResponse.Status
func (r WorkspacecreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkspacecreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TokencreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TokenCreateResponse
}

// Status returns HTTPResponse.Status
func (r TokencreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TokencreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TokenupdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TokenUpdateResponse
}

// Status returns HTTPResponse.Status
func (r TokenupdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TokenupdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SandboxlistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SandboxListResponse
}

// Status returns HTTPResponse.Status
func (r SandboxlistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SandboxlistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SandboxcreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SandboxCreateResponse
}

// Status returns HTTPResponse.Status
func (r SandboxcreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SandboxcreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SandboxgetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SandboxGetResponse
}

// Status returns HTTPResponse.Status
func (r SandboxgetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SandboxgetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SandboxforkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SandboxForkResponse
}

// Status returns HTTPResponse.Status
func (r SandboxforkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SandboxforkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VmhibernateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VMHibernateResponse
}

// Status returns HTTPResponse.Status
func (r VmhibernateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VmhibernateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VmupdateHibernationTimeoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VMUpdateHibernationTimeoutResponse
}

// Status returns HTTPResponse.Status
func (r VmupdateHibernationTimeoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VmupdateHibernationTimeoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VmcreateSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VMCreateSessionResponse
}

// Status returns HTTPResponse.Status
func (r VmcreateSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VmcreateSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VmshutdownResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VMShutdownResponse
}

// Status returns HTTPResponse.Status
func (r VmshutdownResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VmshutdownResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VmupdateSpecsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VMUpdateSpecsResponse
}

// Status returns HTTPResponse.Status
func (r VmupdateSpecsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VmupdateSpecsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VmstartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VMStartResponse
}

// Status returns HTTPResponse.Status
func (r VmstartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VmstartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VmupdateSpecs2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VMUpdateSpecsResponse
}

// Status returns HTTPResponse.Status
func (r VmupdateSpecs2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VmupdateSpecs2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// MetainfoWithResponse request returning *MetainfoResponse
func (c *ClientWithResponses) MetainfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MetainfoResponse, error) {
	rsp, err := c.Metainfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetainfoResponse(rsp)
}

// WorkspacecreateWithBodyWithResponse request with arbitrary body returning *WorkspacecreateResponse
func (c *ClientWithResponses) WorkspacecreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WorkspacecreateResponse, error) {
	rsp, err := c.WorkspacecreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkspacecreateResponse(rsp)
}

func (c *ClientWithResponses) WorkspacecreateWithResponse(ctx context.Context, body WorkspacecreateJSONRequestBody, reqEditors ...RequestEditorFn) (*WorkspacecreateResponse, error) {
	rsp, err := c.Workspacecreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkspacecreateResponse(rsp)
}

// TokencreateWithBodyWithResponse request with arbitrary body returning *TokencreateResponse
func (c *ClientWithResponses) TokencreateWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TokencreateResponse, error) {
	rsp, err := c.TokencreateWithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTokencreateResponse(rsp)
}

func (c *ClientWithResponses) TokencreateWithResponse(ctx context.Context, teamId string, body TokencreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TokencreateResponse, error) {
	rsp, err := c.Tokencreate(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTokencreateResponse(rsp)
}

// TokenupdateWithBodyWithResponse request with arbitrary body returning *TokenupdateResponse
func (c *ClientWithResponses) TokenupdateWithBodyWithResponse(ctx context.Context, teamId string, tokenId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TokenupdateResponse, error) {
	rsp, err := c.TokenupdateWithBody(ctx, teamId, tokenId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTokenupdateResponse(rsp)
}

func (c *ClientWithResponses) TokenupdateWithResponse(ctx context.Context, teamId string, tokenId string, body TokenupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TokenupdateResponse, error) {
	rsp, err := c.Tokenupdate(ctx, teamId, tokenId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTokenupdateResponse(rsp)
}

// SandboxlistWithResponse request returning *SandboxlistResponse
func (c *ClientWithResponses) SandboxlistWithResponse(ctx context.Context, params *SandboxlistParams, reqEditors ...RequestEditorFn) (*SandboxlistResponse, error) {
	rsp, err := c.Sandboxlist(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSandboxlistResponse(rsp)
}

// SandboxcreateWithBodyWithResponse request with arbitrary body returning *SandboxcreateResponse
func (c *ClientWithResponses) SandboxcreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SandboxcreateResponse, error) {
	rsp, err := c.SandboxcreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSandboxcreateResponse(rsp)
}

func (c *ClientWithResponses) SandboxcreateWithResponse(ctx context.Context, body SandboxcreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SandboxcreateResponse, error) {
	rsp, err := c.Sandboxcreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSandboxcreateResponse(rsp)
}

// SandboxgetWithResponse request returning *SandboxgetResponse
func (c *ClientWithResponses) SandboxgetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SandboxgetResponse, error) {
	rsp, err := c.Sandboxget(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSandboxgetResponse(rsp)
}

// SandboxforkWithBodyWithResponse request with arbitrary body returning *SandboxforkResponse
func (c *ClientWithResponses) SandboxforkWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SandboxforkResponse, error) {
	rsp, err := c.SandboxforkWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSandboxforkResponse(rsp)
}

func (c *ClientWithResponses) SandboxforkWithResponse(ctx context.Context, id string, body SandboxforkJSONRequestBody, reqEditors ...RequestEditorFn) (*SandboxforkResponse, error) {
	rsp, err := c.Sandboxfork(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSandboxforkResponse(rsp)
}

// VmhibernateWithBodyWithResponse request with arbitrary body returning *VmhibernateResponse
func (c *ClientWithResponses) VmhibernateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VmhibernateResponse, error) {
	rsp, err := c.VmhibernateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmhibernateResponse(rsp)
}

func (c *ClientWithResponses) VmhibernateWithResponse(ctx context.Context, id string, body VmhibernateJSONRequestBody, reqEditors ...RequestEditorFn) (*VmhibernateResponse, error) {
	rsp, err := c.Vmhibernate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmhibernateResponse(rsp)
}

// VmupdateHibernationTimeoutWithBodyWithResponse request with arbitrary body returning *VmupdateHibernationTimeoutResponse
func (c *ClientWithResponses) VmupdateHibernationTimeoutWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VmupdateHibernationTimeoutResponse, error) {
	rsp, err := c.VmupdateHibernationTimeoutWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmupdateHibernationTimeoutResponse(rsp)
}

func (c *ClientWithResponses) VmupdateHibernationTimeoutWithResponse(ctx context.Context, id string, body VmupdateHibernationTimeoutJSONRequestBody, reqEditors ...RequestEditorFn) (*VmupdateHibernationTimeoutResponse, error) {
	rsp, err := c.VmupdateHibernationTimeout(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmupdateHibernationTimeoutResponse(rsp)
}

// VmcreateSessionWithBodyWithResponse request with arbitrary body returning *VmcreateSessionResponse
func (c *ClientWithResponses) VmcreateSessionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VmcreateSessionResponse, error) {
	rsp, err := c.VmcreateSessionWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmcreateSessionResponse(rsp)
}

func (c *ClientWithResponses) VmcreateSessionWithResponse(ctx context.Context, id string, body VmcreateSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*VmcreateSessionResponse, error) {
	rsp, err := c.VmcreateSession(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmcreateSessionResponse(rsp)
}

// VmshutdownWithBodyWithResponse request with arbitrary body returning *VmshutdownResponse
func (c *ClientWithResponses) VmshutdownWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VmshutdownResponse, error) {
	rsp, err := c.VmshutdownWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmshutdownResponse(rsp)
}

func (c *ClientWithResponses) VmshutdownWithResponse(ctx context.Context, id string, body VmshutdownJSONRequestBody, reqEditors ...RequestEditorFn) (*VmshutdownResponse, error) {
	rsp, err := c.Vmshutdown(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmshutdownResponse(rsp)
}

// VmupdateSpecsWithBodyWithResponse request with arbitrary body returning *VmupdateSpecsResponse
func (c *ClientWithResponses) VmupdateSpecsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VmupdateSpecsResponse, error) {
	rsp, err := c.VmupdateSpecsWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmupdateSpecsResponse(rsp)
}

func (c *ClientWithResponses) VmupdateSpecsWithResponse(ctx context.Context, id string, body VmupdateSpecsJSONRequestBody, reqEditors ...RequestEditorFn) (*VmupdateSpecsResponse, error) {
	rsp, err := c.VmupdateSpecs(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmupdateSpecsResponse(rsp)
}

// VmstartWithBodyWithResponse request with arbitrary body returning *VmstartResponse
func (c *ClientWithResponses) VmstartWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VmstartResponse, error) {
	rsp, err := c.VmstartWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmstartResponse(rsp)
}

func (c *ClientWithResponses) VmstartWithResponse(ctx context.Context, id string, body VmstartJSONRequestBody, reqEditors ...RequestEditorFn) (*VmstartResponse, error) {
	rsp, err := c.Vmstart(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmstartResponse(rsp)
}

// VmupdateSpecs2WithBodyWithResponse request with arbitrary body returning *VmupdateSpecs2Response
func (c *ClientWithResponses) VmupdateSpecs2WithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VmupdateSpecs2Response, error) {
	rsp, err := c.VmupdateSpecs2WithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmupdateSpecs2Response(rsp)
}

func (c *ClientWithResponses) VmupdateSpecs2WithResponse(ctx context.Context, id string, body VmupdateSpecs2JSONRequestBody, reqEditors ...RequestEditorFn) (*VmupdateSpecs2Response, error) {
	rsp, err := c.VmupdateSpecs2(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVmupdateSpecs2Response(rsp)
}

// ParseMetainfoResponse parses an HTTP response from a MetainfoWithResponse call
func ParseMetainfoResponse(rsp *http.Response) (*MetainfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetainfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetaInformation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWorkspacecreateResponse parses an HTTP response from a WorkspacecreateWithResponse call
func ParseWorkspacecreateResponse(rsp *http.Response) (*WorkspacecreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkspacecreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest WorkspaceCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseTokencreateResponse parses an HTTP response from a TokencreateWithResponse call
func ParseTokencreateResponse(rsp *http.Response) (*TokencreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TokencreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TokenCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseTokenupdateResponse parses an HTTP response from a TokenupdateWithResponse call
func ParseTokenupdateResponse(rsp *http.Response) (*TokenupdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TokenupdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TokenUpdateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseSandboxlistResponse parses an HTTP response from a SandboxlistWithResponse call
func ParseSandboxlistResponse(rsp *http.Response) (*SandboxlistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SandboxlistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SandboxListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSandboxcreateResponse parses an HTTP response from a SandboxcreateWithResponse call
func ParseSandboxcreateResponse(rsp *http.Response) (*SandboxcreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SandboxcreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SandboxCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseSandboxgetResponse parses an HTTP response from a SandboxgetWithResponse call
func ParseSandboxgetResponse(rsp *http.Response) (*SandboxgetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SandboxgetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SandboxGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSandboxforkResponse parses an HTTP response from a SandboxforkWithResponse call
func ParseSandboxforkResponse(rsp *http.Response) (*SandboxforkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SandboxforkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SandboxForkResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseVmhibernateResponse parses an HTTP response from a VmhibernateWithResponse call
func ParseVmhibernateResponse(rsp *http.Response) (*VmhibernateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VmhibernateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VMHibernateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVmupdateHibernationTimeoutResponse parses an HTTP response from a VmupdateHibernationTimeoutWithResponse call
func ParseVmupdateHibernationTimeoutResponse(rsp *http.Response) (*VmupdateHibernationTimeoutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VmupdateHibernationTimeoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VMUpdateHibernationTimeoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVmcreateSessionResponse parses an HTTP response from a VmcreateSessionWithResponse call
func ParseVmcreateSessionResponse(rsp *http.Response) (*VmcreateSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VmcreateSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VMCreateSessionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVmshutdownResponse parses an HTTP response from a VmshutdownWithResponse call
func ParseVmshutdownResponse(rsp *http.Response) (*VmshutdownResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VmshutdownResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VMShutdownResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVmupdateSpecsResponse parses an HTTP response from a VmupdateSpecsWithResponse call
func ParseVmupdateSpecsResponse(rsp *http.Response) (*VmupdateSpecsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VmupdateSpecsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VMUpdateSpecsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVmstartResponse parses an HTTP response from a VmstartWithResponse call
func ParseVmstartResponse(rsp *http.Response) (*VmstartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VmstartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VMStartResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVmupdateSpecs2Response parses an HTTP response from a VmupdateSpecs2WithResponse call
func ParseVmupdateSpecs2Response(rsp *http.Response) (*VmupdateSpecs2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VmupdateSpecs2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VMUpdateSpecsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
